// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'interface.dart';

// **************************************************************************
// BuiltValueGenerator
// **************************************************************************

const TextDocumentSyncKind _$TextDocumentSyncKindFull =
    const TextDocumentSyncKind._('full');
const TextDocumentSyncKind _$TextDocumentSyncKindIncremental =
    const TextDocumentSyncKind._('incremental');
const TextDocumentSyncKind _$TextDocumentSyncKindNone =
    const TextDocumentSyncKind._('none');

TextDocumentSyncKind _$TextDocumentSyncKindValueOf(String name) {
  switch (name) {
    case 'full':
      return _$TextDocumentSyncKindFull;
    case 'incremental':
      return _$TextDocumentSyncKindIncremental;
    case 'none':
      return _$TextDocumentSyncKindNone;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<TextDocumentSyncKind> _$TextDocumentSyncKindValues =
    new BuiltSet<TextDocumentSyncKind>(const <TextDocumentSyncKind>[
  _$TextDocumentSyncKindFull,
  _$TextDocumentSyncKindIncremental,
  _$TextDocumentSyncKindNone,
]);

const InsertTextFormat _$InsertTextFormatPlainText =
    const InsertTextFormat._('plainText');
const InsertTextFormat _$InsertTextFormatSnippet =
    const InsertTextFormat._('snippet');

InsertTextFormat _$InsertTextFormatValueOf(String name) {
  switch (name) {
    case 'plainText':
      return _$InsertTextFormatPlainText;
    case 'snippet':
      return _$InsertTextFormatSnippet;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<InsertTextFormat> _$InsertTextFormatValues =
    new BuiltSet<InsertTextFormat>(const <InsertTextFormat>[
  _$InsertTextFormatPlainText,
  _$InsertTextFormatSnippet,
]);

const CompletionItemKind _$CompletionItemKindClassKind =
    const CompletionItemKind._('classKind');
const CompletionItemKind _$CompletionItemKindColor =
    const CompletionItemKind._('color');
const CompletionItemKind _$CompletionItemKindConstructor =
    const CompletionItemKind._('constructor');
const CompletionItemKind _$CompletionItemKindEnumKind =
    const CompletionItemKind._('enumKind');
const CompletionItemKind _$CompletionItemKindField =
    const CompletionItemKind._('field');
const CompletionItemKind _$CompletionItemKindFile =
    const CompletionItemKind._('file');
const CompletionItemKind _$CompletionItemKindFunction =
    const CompletionItemKind._('function');
const CompletionItemKind _$CompletionItemKindInterface =
    const CompletionItemKind._('interface');
const CompletionItemKind _$CompletionItemKindKeyword =
    const CompletionItemKind._('keyword');
const CompletionItemKind _$CompletionItemKindMethod =
    const CompletionItemKind._('method');
const CompletionItemKind _$CompletionItemKindModule =
    const CompletionItemKind._('module');
const CompletionItemKind _$CompletionItemKindProperty =
    const CompletionItemKind._('property');
const CompletionItemKind _$CompletionItemKindReference =
    const CompletionItemKind._('reference');
const CompletionItemKind _$CompletionItemKindSnippet =
    const CompletionItemKind._('snippet');
const CompletionItemKind _$CompletionItemKindText =
    const CompletionItemKind._('text');
const CompletionItemKind _$CompletionItemKindUnit =
    const CompletionItemKind._('unit');
const CompletionItemKind _$CompletionItemKindValue =
    const CompletionItemKind._('value');
const CompletionItemKind _$CompletionItemKindVariable =
    const CompletionItemKind._('variable');

CompletionItemKind _$CompletionItemKindValueOf(String name) {
  switch (name) {
    case 'classKind':
      return _$CompletionItemKindClassKind;
    case 'color':
      return _$CompletionItemKindColor;
    case 'constructor':
      return _$CompletionItemKindConstructor;
    case 'enumKind':
      return _$CompletionItemKindEnumKind;
    case 'field':
      return _$CompletionItemKindField;
    case 'file':
      return _$CompletionItemKindFile;
    case 'function':
      return _$CompletionItemKindFunction;
    case 'interface':
      return _$CompletionItemKindInterface;
    case 'keyword':
      return _$CompletionItemKindKeyword;
    case 'method':
      return _$CompletionItemKindMethod;
    case 'module':
      return _$CompletionItemKindModule;
    case 'property':
      return _$CompletionItemKindProperty;
    case 'reference':
      return _$CompletionItemKindReference;
    case 'snippet':
      return _$CompletionItemKindSnippet;
    case 'text':
      return _$CompletionItemKindText;
    case 'unit':
      return _$CompletionItemKindUnit;
    case 'value':
      return _$CompletionItemKindValue;
    case 'variable':
      return _$CompletionItemKindVariable;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<CompletionItemKind> _$CompletionItemKindValues =
    new BuiltSet<CompletionItemKind>(const <CompletionItemKind>[
  _$CompletionItemKindClassKind,
  _$CompletionItemKindColor,
  _$CompletionItemKindConstructor,
  _$CompletionItemKindEnumKind,
  _$CompletionItemKindField,
  _$CompletionItemKindFile,
  _$CompletionItemKindFunction,
  _$CompletionItemKindInterface,
  _$CompletionItemKindKeyword,
  _$CompletionItemKindMethod,
  _$CompletionItemKindModule,
  _$CompletionItemKindProperty,
  _$CompletionItemKindReference,
  _$CompletionItemKindSnippet,
  _$CompletionItemKindText,
  _$CompletionItemKindUnit,
  _$CompletionItemKindValue,
  _$CompletionItemKindVariable,
]);

const DocumentHighlightKind _$DocumentHighlightKindRead =
    const DocumentHighlightKind._('read');
const DocumentHighlightKind _$DocumentHighlightKindText =
    const DocumentHighlightKind._('text');
const DocumentHighlightKind _$DocumentHighlightKindWrite =
    const DocumentHighlightKind._('write');

DocumentHighlightKind _$DocumentHighlightKindValueOf(String name) {
  switch (name) {
    case 'read':
      return _$DocumentHighlightKindRead;
    case 'text':
      return _$DocumentHighlightKindText;
    case 'write':
      return _$DocumentHighlightKindWrite;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<DocumentHighlightKind> _$DocumentHighlightKindValues =
    new BuiltSet<DocumentHighlightKind>(const <DocumentHighlightKind>[
  _$DocumentHighlightKindRead,
  _$DocumentHighlightKindText,
  _$DocumentHighlightKindWrite,
]);

const SymbolKind _$SymbolKind18 = const SymbolKind._('array');
const SymbolKind _$SymbolKind17 = const SymbolKind._('boolean');
const SymbolKind _$SymbolKind5 = const SymbolKind._('classSymbol');
const SymbolKind _$SymbolKind14 = const SymbolKind._('constant');
const SymbolKind _$SymbolKind9 = const SymbolKind._('constructor');
const SymbolKind _$SymbolKind22 = const SymbolKind._('enumMember');
const SymbolKind _$SymbolKind10 = const SymbolKind._('enumSymbol');
const SymbolKind _$SymbolKind24 = const SymbolKind._('event');
const SymbolKind _$SymbolKind8 = const SymbolKind._('field');
const SymbolKind _$SymbolKind1 = const SymbolKind._('file');
const SymbolKind _$SymbolKind12 = const SymbolKind._('function');
const SymbolKind _$SymbolKind11 = const SymbolKind._('interface');
const SymbolKind _$SymbolKind20 = const SymbolKind._('key');
const SymbolKind _$SymbolKind6 = const SymbolKind._('method');
const SymbolKind _$SymbolKind2 = const SymbolKind._('module');
const SymbolKind _$SymbolKind3 = const SymbolKind._('namespace');
const SymbolKind _$SymbolKind21 = const SymbolKind._('nullSymbol');
const SymbolKind _$SymbolKind16 = const SymbolKind._('number');
const SymbolKind _$SymbolKind19 = const SymbolKind._('object');
const SymbolKind _$SymbolKind25 = const SymbolKind._('operator');
const SymbolKind _$SymbolKind4 = const SymbolKind._('package');
const SymbolKind _$SymbolKind7 = const SymbolKind._('property');
const SymbolKind _$SymbolKind15 = const SymbolKind._('string');
const SymbolKind _$SymbolKind23 = const SymbolKind._('struct');
const SymbolKind _$SymbolKind26 = const SymbolKind._('typeParameter');
const SymbolKind _$SymbolKind13 = const SymbolKind._('variable');

SymbolKind _$SymbolKindValueOf(String name) {
  switch (name) {
    case 'array':
      return _$SymbolKind18;
    case 'boolean':
      return _$SymbolKind17;
    case 'classSymbol':
      return _$SymbolKind5;
    case 'constant':
      return _$SymbolKind14;
    case 'constructor':
      return _$SymbolKind9;
    case 'enumMember':
      return _$SymbolKind22;
    case 'enumSymbol':
      return _$SymbolKind10;
    case 'event':
      return _$SymbolKind24;
    case 'field':
      return _$SymbolKind8;
    case 'file':
      return _$SymbolKind1;
    case 'function':
      return _$SymbolKind12;
    case 'interface':
      return _$SymbolKind11;
    case 'key':
      return _$SymbolKind20;
    case 'method':
      return _$SymbolKind6;
    case 'module':
      return _$SymbolKind2;
    case 'namespace':
      return _$SymbolKind3;
    case 'nullSymbol':
      return _$SymbolKind21;
    case 'number':
      return _$SymbolKind16;
    case 'object':
      return _$SymbolKind19;
    case 'operator':
      return _$SymbolKind25;
    case 'package':
      return _$SymbolKind4;
    case 'property':
      return _$SymbolKind7;
    case 'string':
      return _$SymbolKind15;
    case 'struct':
      return _$SymbolKind23;
    case 'typeParameter':
      return _$SymbolKind26;
    case 'variable':
      return _$SymbolKind13;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<SymbolKind> _$SymbolKindValues =
    new BuiltSet<SymbolKind>(const <SymbolKind>[
  _$SymbolKind18,
  _$SymbolKind17,
  _$SymbolKind5,
  _$SymbolKind14,
  _$SymbolKind9,
  _$SymbolKind22,
  _$SymbolKind10,
  _$SymbolKind24,
  _$SymbolKind8,
  _$SymbolKind1,
  _$SymbolKind12,
  _$SymbolKind11,
  _$SymbolKind20,
  _$SymbolKind6,
  _$SymbolKind2,
  _$SymbolKind3,
  _$SymbolKind21,
  _$SymbolKind16,
  _$SymbolKind19,
  _$SymbolKind25,
  _$SymbolKind4,
  _$SymbolKind7,
  _$SymbolKind15,
  _$SymbolKind23,
  _$SymbolKind26,
  _$SymbolKind13,
]);

const MessageType _$MessageType1 = const MessageType._('error');
const MessageType _$MessageType3 = const MessageType._('info');
const MessageType _$MessageType4 = const MessageType._('log');
const MessageType _$MessageType2 = const MessageType._('warning');

MessageType _$MessageTypeValueOf(String name) {
  switch (name) {
    case 'error':
      return _$MessageType1;
    case 'info':
      return _$MessageType3;
    case 'log':
      return _$MessageType4;
    case 'warning':
      return _$MessageType2;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<MessageType> _$MessageTypeValues =
    new BuiltSet<MessageType>(const <MessageType>[
  _$MessageType1,
  _$MessageType3,
  _$MessageType4,
  _$MessageType2,
]);

Serializers _$_serializers = (new Serializers().toBuilder()
      ..add(ApplyWorkspaceEditParams.serializer)
      ..add(ClientCapabilities.serializer)
      ..add(CodeActionCapabilities.serializer)
      ..add(CodeActionContext.serializer)
      ..add(CodeActionKinds.serializer)
      ..add(CodeActionLiteralSupport.serializer)
      ..add(CodeLensOptions.serializer)
      ..add(Command.serializer)
      ..add(CompletionCapabilities.serializer)
      ..add(CompletionItem.serializer)
      ..add(CompletionItemCapabilities.serializer)
      ..add(CompletionItemKind.serializer)
      ..add(CompletionList.serializer)
      ..add(CompletionOptions.serializer)
      ..add(Diagnostic.serializer)
      ..add(Diagnostics.serializer)
      ..add(DocumentHighlight.serializer)
      ..add(DocumentHighlightKind.serializer)
      ..add(DocumentLinkOptions.serializer)
      ..add(DocumentOnTypeFormattingOptions.serializer)
      ..add(DynamicRegistrationCapability.serializer)
      ..add(ExecuteCommandOptions.serializer)
      ..add(HoverCapabilities.serializer)
      ..add(InsertTextFormat.serializer)
      ..add(Location.serializer)
      ..add(MessageType.serializer)
      ..add(Position.serializer)
      ..add(Range.serializer)
      ..add(ReferenceContext.serializer)
      ..add(SaveOptions.serializer)
      ..add(ServerCapabilities.serializer)
      ..add(ShowMessageParams.serializer)
      ..add(SignatureHelpOptions.serializer)
      ..add(SymbolInformation.serializer)
      ..add(SymbolKind.serializer)
      ..add(SynchronizationCapabilities.serializer)
      ..add(TextDocumentClientCapabilities.serializer)
      ..add(TextDocumentContentChangeEvent.serializer)
      ..add(TextDocumentIdentifier.serializer)
      ..add(TextDocumentItem.serializer)
      ..add(TextDocumentSyncKind.serializer)
      ..add(TextDocumentSyncOptions.serializer)
      ..add(TextEdit.serializer)
      ..add(VersionedTextDocumentIdentifier.serializer)
      ..add(WorkspaceClientCapabilities.serializer)
      ..add(WorkspaceEdit.serializer)
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(CompletionItem)]),
          () => new ListBuilder<CompletionItem>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(Diagnostic)]),
          () => new ListBuilder<Diagnostic>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(Diagnostic)]),
          () => new ListBuilder<Diagnostic>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(String)]),
          () => new ListBuilder<String>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(String)]),
          () => new ListBuilder<String>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(String)]),
          () => new ListBuilder<String>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(String)]),
          () => new ListBuilder<String>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(String)]),
          () => new ListBuilder<String>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(String)]),
          () => new ListBuilder<String>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(TextEdit)]),
          () => new ListBuilder<TextEdit>())
      ..addBuilderFactory(
          const FullType(BuiltMap,
              const [const FullType(dynamic), const FullType(dynamic)]),
          () => new MapBuilder<dynamic, dynamic>())
      ..addBuilderFactory(
          const FullType(BuiltList, const [const FullType(dynamic)]),
          () => new ListBuilder<dynamic>())
      ..addBuilderFactory(
          const FullType(BuiltMap, const [
            const FullType(String),
            const FullType(BuiltList, const [const FullType(TextEdit)])
          ]),
          () => new MapBuilder<String, BuiltList<TextEdit>>()))
    .build();
Serializer<ServerCapabilities> _$serverCapabilitiesSerializer =
    new _$ServerCapabilitiesSerializer();
Serializer<ClientCapabilities> _$clientCapabilitiesSerializer =
    new _$ClientCapabilitiesSerializer();
Serializer<TextDocumentClientCapabilities>
    _$textDocumentClientCapabilitiesSerializer =
    new _$TextDocumentClientCapabilitiesSerializer();
Serializer<SynchronizationCapabilities>
    _$synchronizationCapabilitiesSerializer =
    new _$SynchronizationCapabilitiesSerializer();
Serializer<HoverCapabilities> _$hoverCapabilitiesSerializer =
    new _$HoverCapabilitiesSerializer();
Serializer<WorkspaceClientCapabilities>
    _$workspaceClientCapabilitiesSerializer =
    new _$WorkspaceClientCapabilitiesSerializer();
Serializer<DynamicRegistrationCapability>
    _$dynamicRegistrationCapabilitySerializer =
    new _$DynamicRegistrationCapabilitySerializer();
Serializer<CodeActionCapabilities> _$codeActionCapabilitiesSerializer =
    new _$CodeActionCapabilitiesSerializer();
Serializer<CodeActionLiteralSupport> _$codeActionLiteralSupportSerializer =
    new _$CodeActionLiteralSupportSerializer();
Serializer<CodeActionKinds> _$codeActionKindsSerializer =
    new _$CodeActionKindsSerializer();
Serializer<CompletionCapabilities> _$completionCapabilitiesSerializer =
    new _$CompletionCapabilitiesSerializer();
Serializer<CompletionItemCapabilities> _$completionItemCapabilitiesSerializer =
    new _$CompletionItemCapabilitiesSerializer();
Serializer<CodeLensOptions> _$codeLensOptionsSerializer =
    new _$CodeLensOptionsSerializer();
Serializer<CompletionOptions> _$completionOptionsSerializer =
    new _$CompletionOptionsSerializer();
Serializer<DocumentLinkOptions> _$documentLinkOptionsSerializer =
    new _$DocumentLinkOptionsSerializer();
Serializer<DocumentOnTypeFormattingOptions>
    _$documentOnTypeFormattingOptionsSerializer =
    new _$DocumentOnTypeFormattingOptionsSerializer();
Serializer<ExecuteCommandOptions> _$executeCommandOptionsSerializer =
    new _$ExecuteCommandOptionsSerializer();
Serializer<SignatureHelpOptions> _$signatureHelpOptionsSerializer =
    new _$SignatureHelpOptionsSerializer();
Serializer<TextDocumentSyncOptions> _$textDocumentSyncOptionsSerializer =
    new _$TextDocumentSyncOptionsSerializer();
Serializer<TextDocumentSyncKind> _$textDocumentSyncKindSerializer =
    new _$TextDocumentSyncKindSerializer();
Serializer<SaveOptions> _$saveOptionsSerializer = new _$SaveOptionsSerializer();
Serializer<TextDocumentItem> _$textDocumentItemSerializer =
    new _$TextDocumentItemSerializer();
Serializer<VersionedTextDocumentIdentifier>
    _$versionedTextDocumentIdentifierSerializer =
    new _$VersionedTextDocumentIdentifierSerializer();
Serializer<TextDocumentContentChangeEvent>
    _$textDocumentContentChangeEventSerializer =
    new _$TextDocumentContentChangeEventSerializer();
Serializer<Range> _$rangeSerializer = new _$RangeSerializer();
Serializer<Position> _$positionSerializer = new _$PositionSerializer();
Serializer<TextDocumentIdentifier> _$textDocumentIdentifierSerializer =
    new _$TextDocumentIdentifierSerializer();
Serializer<CompletionList> _$completionListSerializer =
    new _$CompletionListSerializer();
Serializer<CompletionItem> _$completionItemSerializer =
    new _$CompletionItemSerializer();
Serializer<TextEdit> _$textEditSerializer = new _$TextEditSerializer();
Serializer<Command> _$commandSerializer = new _$CommandSerializer();
Serializer<InsertTextFormat> _$insertTextFormatSerializer =
    new _$InsertTextFormatSerializer();
Serializer<CompletionItemKind> _$completionItemKindSerializer =
    new _$CompletionItemKindSerializer();
Serializer<Location> _$locationSerializer = new _$LocationSerializer();
Serializer<ReferenceContext> _$referenceContextSerializer =
    new _$ReferenceContextSerializer();
Serializer<DocumentHighlight> _$documentHighlightSerializer =
    new _$DocumentHighlightSerializer();
Serializer<DocumentHighlightKind> _$documentHighlightKindSerializer =
    new _$DocumentHighlightKindSerializer();
Serializer<SymbolInformation> _$symbolInformationSerializer =
    new _$SymbolInformationSerializer();
Serializer<SymbolKind> _$symbolKindSerializer = new _$SymbolKindSerializer();
Serializer<CodeActionContext> _$codeActionContextSerializer =
    new _$CodeActionContextSerializer();
Serializer<Diagnostic> _$diagnosticSerializer = new _$DiagnosticSerializer();
Serializer<WorkspaceEdit> _$workspaceEditSerializer =
    new _$WorkspaceEditSerializer();
Serializer<Diagnostics> _$diagnosticsSerializer = new _$DiagnosticsSerializer();
Serializer<ApplyWorkspaceEditParams> _$applyWorkspaceEditParamsSerializer =
    new _$ApplyWorkspaceEditParamsSerializer();
Serializer<ShowMessageParams> _$showMessageParamsSerializer =
    new _$ShowMessageParamsSerializer();
Serializer<MessageType> _$messageTypeSerializer = new _$MessageTypeSerializer();

class _$ServerCapabilitiesSerializer
    implements StructuredSerializer<ServerCapabilities> {
  @override
  final Iterable<Type> types = const [ServerCapabilities, _$ServerCapabilities];
  @override
  final String wireName = 'ServerCapabilities';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, ServerCapabilities object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.codeActionProvider;
    if (value != null) {
      result
        ..add('codeActionProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.codeLensProvider;
    if (value != null) {
      result
        ..add('codeLensProvider')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(CodeLensOptions)));
    }
    value = object.completionProvider;
    if (value != null) {
      result
        ..add('completionProvider')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(CompletionOptions)));
    }
    value = object.definitionProvider;
    if (value != null) {
      result
        ..add('definitionProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.documentFormattingProvider;
    if (value != null) {
      result
        ..add('documentFormattingProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.documentHighlightProvider;
    if (value != null) {
      result
        ..add('documentHighlightProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.documentLinkProvider;
    if (value != null) {
      result
        ..add('documentLinkProvider')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DocumentLinkOptions)));
    }
    value = object.documentOnTypeFormattingProvider;
    if (value != null) {
      result
        ..add('documentOnTypeFormattingProvider')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DocumentOnTypeFormattingOptions)));
    }
    value = object.documentRangeFormattingProvider;
    if (value != null) {
      result
        ..add('documentRangeFormattingProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.documentSymbolProvider;
    if (value != null) {
      result
        ..add('documentSymbolProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.executeCommandProvider;
    if (value != null) {
      result
        ..add('executeCommandProvider')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(ExecuteCommandOptions)));
    }
    value = object.hoverProvider;
    if (value != null) {
      result
        ..add('hoverProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.implementationProvider;
    if (value != null) {
      result
        ..add('implementationProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.referencesProvider;
    if (value != null) {
      result
        ..add('referencesProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.renameProvider;
    if (value != null) {
      result
        ..add('renameProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.signatureHelpProvider;
    if (value != null) {
      result
        ..add('signatureHelpProvider')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(SignatureHelpOptions)));
    }
    value = object.textDocumentSync;
    if (value != null) {
      result
        ..add('textDocumentSync')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(TextDocumentSyncOptions)));
    }
    value = object.workspaceSymbolProvider;
    if (value != null) {
      result
        ..add('workspaceSymbolProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  ServerCapabilities deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new ServerCapabilitiesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'codeActionProvider':
          result.codeActionProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'codeLensProvider':
          result.codeLensProvider.replace(serializers.deserialize(value,
                  specifiedType: const FullType(CodeLensOptions))!
              as CodeLensOptions);
          break;
        case 'completionProvider':
          result.completionProvider.replace(serializers.deserialize(value,
                  specifiedType: const FullType(CompletionOptions))!
              as CompletionOptions);
          break;
        case 'definitionProvider':
          result.definitionProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'documentFormattingProvider':
          result.documentFormattingProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'documentHighlightProvider':
          result.documentHighlightProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'documentLinkProvider':
          result.documentLinkProvider.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DocumentLinkOptions))!
              as DocumentLinkOptions);
          break;
        case 'documentOnTypeFormattingProvider':
          result.documentOnTypeFormattingProvider.replace(
              serializers.deserialize(value,
                      specifiedType:
                          const FullType(DocumentOnTypeFormattingOptions))!
                  as DocumentOnTypeFormattingOptions);
          break;
        case 'documentRangeFormattingProvider':
          result.documentRangeFormattingProvider = serializers
              .deserialize(value, specifiedType: const FullType(bool)) as bool?;
          break;
        case 'documentSymbolProvider':
          result.documentSymbolProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'executeCommandProvider':
          result.executeCommandProvider.replace(serializers.deserialize(value,
                  specifiedType: const FullType(ExecuteCommandOptions))!
              as ExecuteCommandOptions);
          break;
        case 'hoverProvider':
          result.hoverProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'implementationProvider':
          result.implementationProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'referencesProvider':
          result.referencesProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'renameProvider':
          result.renameProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'signatureHelpProvider':
          result.signatureHelpProvider.replace(serializers.deserialize(value,
                  specifiedType: const FullType(SignatureHelpOptions))!
              as SignatureHelpOptions);
          break;
        case 'textDocumentSync':
          result.textDocumentSync.replace(serializers.deserialize(value,
                  specifiedType: const FullType(TextDocumentSyncOptions))!
              as TextDocumentSyncOptions);
          break;
        case 'workspaceSymbolProvider':
          result.workspaceSymbolProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$ClientCapabilitiesSerializer
    implements StructuredSerializer<ClientCapabilities> {
  @override
  final Iterable<Type> types = const [ClientCapabilities, _$ClientCapabilities];
  @override
  final String wireName = 'ClientCapabilities';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, ClientCapabilities object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.textDocument;
    if (value != null) {
      result
        ..add('textDocument')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(TextDocumentClientCapabilities)));
    }
    value = object.workspace;
    if (value != null) {
      result
        ..add('workspace')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(WorkspaceClientCapabilities)));
    }
    return result;
  }

  @override
  ClientCapabilities deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new ClientCapabilitiesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'textDocument':
          result.textDocument.replace(serializers.deserialize(value,
                  specifiedType:
                      const FullType(TextDocumentClientCapabilities))!
              as TextDocumentClientCapabilities);
          break;
        case 'workspace':
          result.workspace.replace(serializers.deserialize(value,
                  specifiedType: const FullType(WorkspaceClientCapabilities))!
              as WorkspaceClientCapabilities);
          break;
      }
    }

    return result.build();
  }
}

class _$TextDocumentClientCapabilitiesSerializer
    implements StructuredSerializer<TextDocumentClientCapabilities> {
  @override
  final Iterable<Type> types = const [
    TextDocumentClientCapabilities,
    _$TextDocumentClientCapabilities
  ];
  @override
  final String wireName = 'TextDocumentClientCapabilities';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, TextDocumentClientCapabilities object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.codeAction;
    if (value != null) {
      result
        ..add('codeAction')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(CodeActionCapabilities)));
    }
    value = object.codeLens;
    if (value != null) {
      result
        ..add('codeLens')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.completion;
    if (value != null) {
      result
        ..add('completion')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(CompletionCapabilities)));
    }
    value = object.definition;
    if (value != null) {
      result
        ..add('definition')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.documentHighlight;
    if (value != null) {
      result
        ..add('documentHighlight')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.documentLink;
    if (value != null) {
      result
        ..add('documentLink')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.documentSymbol;
    if (value != null) {
      result
        ..add('documentSymbol')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.formatting;
    if (value != null) {
      result
        ..add('formatting')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.hover;
    if (value != null) {
      result
        ..add('hover')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(HoverCapabilities)));
    }
    value = object.onTypeFormatting;
    if (value != null) {
      result
        ..add('onTypeFormatting')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.references;
    if (value != null) {
      result
        ..add('references')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.rename;
    if (value != null) {
      result
        ..add('rename')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.synchronization;
    if (value != null) {
      result
        ..add('synchronization')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(SynchronizationCapabilities)));
    }
    return result;
  }

  @override
  TextDocumentClientCapabilities deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new TextDocumentClientCapabilitiesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'codeAction':
          result.codeAction.replace(serializers.deserialize(value,
                  specifiedType: const FullType(CodeActionCapabilities))!
              as CodeActionCapabilities);
          break;
        case 'codeLens':
          result.codeLens.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'completion':
          result.completion.replace(serializers.deserialize(value,
                  specifiedType: const FullType(CompletionCapabilities))!
              as CompletionCapabilities);
          break;
        case 'definition':
          result.definition.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'documentHighlight':
          result.documentHighlight.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'documentLink':
          result.documentLink.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'documentSymbol':
          result.documentSymbol.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'formatting':
          result.formatting.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'hover':
          result.hover.replace(serializers.deserialize(value,
                  specifiedType: const FullType(HoverCapabilities))!
              as HoverCapabilities);
          break;
        case 'onTypeFormatting':
          result.onTypeFormatting.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'references':
          result.references.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'rename':
          result.rename.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'synchronization':
          result.synchronization.replace(serializers.deserialize(value,
                  specifiedType: const FullType(SynchronizationCapabilities))!
              as SynchronizationCapabilities);
          break;
      }
    }

    return result.build();
  }
}

class _$SynchronizationCapabilitiesSerializer
    implements StructuredSerializer<SynchronizationCapabilities> {
  @override
  final Iterable<Type> types = const [
    SynchronizationCapabilities,
    _$SynchronizationCapabilities
  ];
  @override
  final String wireName = 'SynchronizationCapabilities';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, SynchronizationCapabilities object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.didSave;
    if (value != null) {
      result
        ..add('didSave')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.dynamicRegistration;
    if (value != null) {
      result
        ..add('dynamicRegistration')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.willSave;
    if (value != null) {
      result
        ..add('willSave')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.willSaveWaitUntil;
    if (value != null) {
      result
        ..add('willSaveWaitUntil')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  SynchronizationCapabilities deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new SynchronizationCapabilitiesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'didSave':
          result.didSave = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'dynamicRegistration':
          result.dynamicRegistration = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'willSave':
          result.willSave = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'willSaveWaitUntil':
          result.willSaveWaitUntil = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$HoverCapabilitiesSerializer
    implements StructuredSerializer<HoverCapabilities> {
  @override
  final Iterable<Type> types = const [HoverCapabilities, _$HoverCapabilities];
  @override
  final String wireName = 'HoverCapabilities';

  @override
  Iterable<Object?> serialize(Serializers serializers, HoverCapabilities object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.contentFormat;
    if (value != null) {
      result
        ..add('contentFormat')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    value = object.dynamicRegistration;
    if (value != null) {
      result
        ..add('dynamicRegistration')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  HoverCapabilities deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new HoverCapabilitiesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'contentFormat':
          result.contentFormat.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object?>);
          break;
        case 'dynamicRegistration':
          result.dynamicRegistration = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$WorkspaceClientCapabilitiesSerializer
    implements StructuredSerializer<WorkspaceClientCapabilities> {
  @override
  final Iterable<Type> types = const [
    WorkspaceClientCapabilities,
    _$WorkspaceClientCapabilities
  ];
  @override
  final String wireName = 'WorkspaceClientCapabilities';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, WorkspaceClientCapabilities object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.applyEdit;
    if (value != null) {
      result
        ..add('applyEdit')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.didChangeConfiguration;
    if (value != null) {
      result
        ..add('didChangeConfiguration')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.didChangeWatchedFiles;
    if (value != null) {
      result
        ..add('didChangeWatchedFiles')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.executeCommand;
    if (value != null) {
      result
        ..add('executeCommand')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    value = object.symbol;
    if (value != null) {
      result
        ..add('symbol')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DynamicRegistrationCapability)));
    }
    return result;
  }

  @override
  WorkspaceClientCapabilities deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new WorkspaceClientCapabilitiesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'applyEdit':
          result.applyEdit = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'didChangeConfiguration':
          result.didChangeConfiguration.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'didChangeWatchedFiles':
          result.didChangeWatchedFiles.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'executeCommand':
          result.executeCommand.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
        case 'symbol':
          result.symbol.replace(serializers.deserialize(value,
                  specifiedType: const FullType(DynamicRegistrationCapability))!
              as DynamicRegistrationCapability);
          break;
      }
    }

    return result.build();
  }
}

class _$DynamicRegistrationCapabilitySerializer
    implements StructuredSerializer<DynamicRegistrationCapability> {
  @override
  final Iterable<Type> types = const [
    DynamicRegistrationCapability,
    _$DynamicRegistrationCapability
  ];
  @override
  final String wireName = 'DynamicRegistrationCapability';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, DynamicRegistrationCapability object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.dynamicRegistration;
    if (value != null) {
      result
        ..add('dynamicRegistration')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  DynamicRegistrationCapability deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new DynamicRegistrationCapabilityBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'dynamicRegistration':
          result.dynamicRegistration = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$CodeActionCapabilitiesSerializer
    implements StructuredSerializer<CodeActionCapabilities> {
  @override
  final Iterable<Type> types = const [
    CodeActionCapabilities,
    _$CodeActionCapabilities
  ];
  @override
  final String wireName = 'CodeActionCapabilities';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, CodeActionCapabilities object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.codeActionLiteralSupport;
    if (value != null) {
      result
        ..add('codeActionLiteralSupport')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(CodeActionLiteralSupport)));
    }
    value = object.dynamicRegistration;
    if (value != null) {
      result
        ..add('dynamicRegistration')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  CodeActionCapabilities deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CodeActionCapabilitiesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'codeActionLiteralSupport':
          result.codeActionLiteralSupport.replace(serializers.deserialize(value,
                  specifiedType: const FullType(CodeActionLiteralSupport))!
              as CodeActionLiteralSupport);
          break;
        case 'dynamicRegistration':
          result.dynamicRegistration = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$CodeActionLiteralSupportSerializer
    implements StructuredSerializer<CodeActionLiteralSupport> {
  @override
  final Iterable<Type> types = const [
    CodeActionLiteralSupport,
    _$CodeActionLiteralSupport
  ];
  @override
  final String wireName = 'CodeActionLiteralSupport';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, CodeActionLiteralSupport object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.codeActionKind;
    if (value != null) {
      result
        ..add('codeActionKind')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(CodeActionKinds)));
    }
    return result;
  }

  @override
  CodeActionLiteralSupport deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CodeActionLiteralSupportBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'codeActionKind':
          result.codeActionKind.replace(serializers.deserialize(value,
                  specifiedType: const FullType(CodeActionKinds))!
              as CodeActionKinds);
          break;
      }
    }

    return result.build();
  }
}

class _$CodeActionKindsSerializer
    implements StructuredSerializer<CodeActionKinds> {
  @override
  final Iterable<Type> types = const [CodeActionKinds, _$CodeActionKinds];
  @override
  final String wireName = 'CodeActionKinds';

  @override
  Iterable<Object?> serialize(Serializers serializers, CodeActionKinds object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.valueSet;
    if (value != null) {
      result
        ..add('valueSet')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    return result;
  }

  @override
  CodeActionKinds deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CodeActionKindsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'valueSet':
          result.valueSet.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$CompletionCapabilitiesSerializer
    implements StructuredSerializer<CompletionCapabilities> {
  @override
  final Iterable<Type> types = const [
    CompletionCapabilities,
    _$CompletionCapabilities
  ];
  @override
  final String wireName = 'CompletionCapabilities';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, CompletionCapabilities object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.completionItem;
    if (value != null) {
      result
        ..add('completionItem')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(CompletionItemCapabilities)));
    }
    value = object.dynamicRegistration;
    if (value != null) {
      result
        ..add('dynamicRegistration')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  CompletionCapabilities deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CompletionCapabilitiesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'completionItem':
          result.completionItem.replace(serializers.deserialize(value,
                  specifiedType: const FullType(CompletionItemCapabilities))!
              as CompletionItemCapabilities);
          break;
        case 'dynamicRegistration':
          result.dynamicRegistration = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$CompletionItemCapabilitiesSerializer
    implements StructuredSerializer<CompletionItemCapabilities> {
  @override
  final Iterable<Type> types = const [
    CompletionItemCapabilities,
    _$CompletionItemCapabilities
  ];
  @override
  final String wireName = 'CompletionItemCapabilities';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, CompletionItemCapabilities object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.snippetSupport;
    if (value != null) {
      result
        ..add('snippetSupport')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  CompletionItemCapabilities deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CompletionItemCapabilitiesBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'snippetSupport':
          result.snippetSupport = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$CodeLensOptionsSerializer
    implements StructuredSerializer<CodeLensOptions> {
  @override
  final Iterable<Type> types = const [CodeLensOptions, _$CodeLensOptions];
  @override
  final String wireName = 'CodeLensOptions';

  @override
  Iterable<Object?> serialize(Serializers serializers, CodeLensOptions object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.resolveProvider;
    if (value != null) {
      result
        ..add('resolveProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  CodeLensOptions deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CodeLensOptionsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'resolveProvider':
          result.resolveProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$CompletionOptionsSerializer
    implements StructuredSerializer<CompletionOptions> {
  @override
  final Iterable<Type> types = const [CompletionOptions, _$CompletionOptions];
  @override
  final String wireName = 'CompletionOptions';

  @override
  Iterable<Object?> serialize(Serializers serializers, CompletionOptions object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.resolveProvider;
    if (value != null) {
      result
        ..add('resolveProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.triggerCharacters;
    if (value != null) {
      result
        ..add('triggerCharacters')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    return result;
  }

  @override
  CompletionOptions deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CompletionOptionsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'resolveProvider':
          result.resolveProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'triggerCharacters':
          result.triggerCharacters.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$DocumentLinkOptionsSerializer
    implements StructuredSerializer<DocumentLinkOptions> {
  @override
  final Iterable<Type> types = const [
    DocumentLinkOptions,
    _$DocumentLinkOptions
  ];
  @override
  final String wireName = 'DocumentLinkOptions';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, DocumentLinkOptions object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.resolveProvider;
    if (value != null) {
      result
        ..add('resolveProvider')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  DocumentLinkOptions deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new DocumentLinkOptionsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'resolveProvider':
          result.resolveProvider = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$DocumentOnTypeFormattingOptionsSerializer
    implements StructuredSerializer<DocumentOnTypeFormattingOptions> {
  @override
  final Iterable<Type> types = const [
    DocumentOnTypeFormattingOptions,
    _$DocumentOnTypeFormattingOptions
  ];
  @override
  final String wireName = 'DocumentOnTypeFormattingOptions';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, DocumentOnTypeFormattingOptions object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.firstTriggerCharacter;
    if (value != null) {
      result
        ..add('firstTriggerCharacter')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.moreTriggerCharacter;
    if (value != null) {
      result
        ..add('moreTriggerCharacter')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    return result;
  }

  @override
  DocumentOnTypeFormattingOptions deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new DocumentOnTypeFormattingOptionsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'firstTriggerCharacter':
          result.firstTriggerCharacter = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'moreTriggerCharacter':
          result.moreTriggerCharacter.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$ExecuteCommandOptionsSerializer
    implements StructuredSerializer<ExecuteCommandOptions> {
  @override
  final Iterable<Type> types = const [
    ExecuteCommandOptions,
    _$ExecuteCommandOptions
  ];
  @override
  final String wireName = 'ExecuteCommandOptions';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, ExecuteCommandOptions object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.commands;
    if (value != null) {
      result
        ..add('commands')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    return result;
  }

  @override
  ExecuteCommandOptions deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new ExecuteCommandOptionsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'commands':
          result.commands.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$SignatureHelpOptionsSerializer
    implements StructuredSerializer<SignatureHelpOptions> {
  @override
  final Iterable<Type> types = const [
    SignatureHelpOptions,
    _$SignatureHelpOptions
  ];
  @override
  final String wireName = 'SignatureHelpOptions';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, SignatureHelpOptions object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.triggerCharacters;
    if (value != null) {
      result
        ..add('triggerCharacters')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    return result;
  }

  @override
  SignatureHelpOptions deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new SignatureHelpOptionsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'triggerCharacters':
          result.triggerCharacters.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$TextDocumentSyncOptionsSerializer
    implements StructuredSerializer<TextDocumentSyncOptions> {
  @override
  final Iterable<Type> types = const [
    TextDocumentSyncOptions,
    _$TextDocumentSyncOptions
  ];
  @override
  final String wireName = 'TextDocumentSyncOptions';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, TextDocumentSyncOptions object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.change;
    if (value != null) {
      result
        ..add('change')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(TextDocumentSyncKind)));
    }
    value = object.openClose;
    if (value != null) {
      result
        ..add('openClose')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.save;
    if (value != null) {
      result
        ..add('save')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(SaveOptions)));
    }
    value = object.willSave;
    if (value != null) {
      result
        ..add('willSave')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.willSaveWaitUntil;
    if (value != null) {
      result
        ..add('willSaveWaitUntil')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  TextDocumentSyncOptions deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new TextDocumentSyncOptionsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'change':
          result.change = serializers.deserialize(value,
                  specifiedType: const FullType(TextDocumentSyncKind))
              as TextDocumentSyncKind?;
          break;
        case 'openClose':
          result.openClose = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'save':
          result.save.replace(serializers.deserialize(value,
              specifiedType: const FullType(SaveOptions))! as SaveOptions);
          break;
        case 'willSave':
          result.willSave = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'willSaveWaitUntil':
          result.willSaveWaitUntil = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$TextDocumentSyncKindSerializer
    implements PrimitiveSerializer<TextDocumentSyncKind> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'full': 1,
    'incremental': 2,
    'none': 0,
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    1: 'full',
    2: 'incremental',
    0: 'none',
  };

  @override
  final Iterable<Type> types = const <Type>[TextDocumentSyncKind];
  @override
  final String wireName = 'TextDocumentSyncKind';

  @override
  Object serialize(Serializers serializers, TextDocumentSyncKind object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  TextDocumentSyncKind deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      TextDocumentSyncKind.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$SaveOptionsSerializer implements StructuredSerializer<SaveOptions> {
  @override
  final Iterable<Type> types = const [SaveOptions, _$SaveOptions];
  @override
  final String wireName = 'SaveOptions';

  @override
  Iterable<Object?> serialize(Serializers serializers, SaveOptions object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.includeText;
    if (value != null) {
      result
        ..add('includeText')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  SaveOptions deserialize(Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new SaveOptionsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'includeText':
          result.includeText = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$TextDocumentItemSerializer
    implements StructuredSerializer<TextDocumentItem> {
  @override
  final Iterable<Type> types = const [TextDocumentItem, _$TextDocumentItem];
  @override
  final String wireName = 'TextDocumentItem';

  @override
  Iterable<Object?> serialize(Serializers serializers, TextDocumentItem object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.languageId;
    if (value != null) {
      result
        ..add('languageId')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.text;
    if (value != null) {
      result
        ..add('text')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.uri;
    if (value != null) {
      result
        ..add('uri')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.version;
    if (value != null) {
      result
        ..add('version')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    return result;
  }

  @override
  TextDocumentItem deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new TextDocumentItemBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'languageId':
          result.languageId = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'text':
          result.text = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'uri':
          result.uri = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'version':
          result.version = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
      }
    }

    return result.build();
  }
}

class _$VersionedTextDocumentIdentifierSerializer
    implements StructuredSerializer<VersionedTextDocumentIdentifier> {
  @override
  final Iterable<Type> types = const [
    VersionedTextDocumentIdentifier,
    _$VersionedTextDocumentIdentifier
  ];
  @override
  final String wireName = 'VersionedTextDocumentIdentifier';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, VersionedTextDocumentIdentifier object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.uri;
    if (value != null) {
      result
        ..add('uri')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.version;
    if (value != null) {
      result
        ..add('version')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    return result;
  }

  @override
  VersionedTextDocumentIdentifier deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new VersionedTextDocumentIdentifierBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'uri':
          result.uri = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'version':
          result.version = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
      }
    }

    return result.build();
  }
}

class _$TextDocumentContentChangeEventSerializer
    implements StructuredSerializer<TextDocumentContentChangeEvent> {
  @override
  final Iterable<Type> types = const [
    TextDocumentContentChangeEvent,
    _$TextDocumentContentChangeEvent
  ];
  @override
  final String wireName = 'TextDocumentContentChangeEvent';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, TextDocumentContentChangeEvent object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.range;
    if (value != null) {
      result
        ..add('range')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(Range)));
    }
    value = object.rangeLength;
    if (value != null) {
      result
        ..add('rangeLength')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.text;
    if (value != null) {
      result
        ..add('text')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  TextDocumentContentChangeEvent deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new TextDocumentContentChangeEventBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'range':
          result.range.replace(serializers.deserialize(value,
              specifiedType: const FullType(Range))! as Range);
          break;
        case 'rangeLength':
          result.rangeLength = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'text':
          result.text = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$RangeSerializer implements StructuredSerializer<Range> {
  @override
  final Iterable<Type> types = const [Range, _$Range];
  @override
  final String wireName = 'Range';

  @override
  Iterable<Object?> serialize(Serializers serializers, Range object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.end;
    if (value != null) {
      result
        ..add('end')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Position)));
    }
    value = object.start;
    if (value != null) {
      result
        ..add('start')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Position)));
    }
    return result;
  }

  @override
  Range deserialize(Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new RangeBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'end':
          result.end.replace(serializers.deserialize(value,
              specifiedType: const FullType(Position))! as Position);
          break;
        case 'start':
          result.start.replace(serializers.deserialize(value,
              specifiedType: const FullType(Position))! as Position);
          break;
      }
    }

    return result.build();
  }
}

class _$PositionSerializer implements StructuredSerializer<Position> {
  @override
  final Iterable<Type> types = const [Position, _$Position];
  @override
  final String wireName = 'Position';

  @override
  Iterable<Object?> serialize(Serializers serializers, Position object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.character;
    if (value != null) {
      result
        ..add('character')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.line;
    if (value != null) {
      result
        ..add('line')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    return result;
  }

  @override
  Position deserialize(Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new PositionBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'character':
          result.character = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'line':
          result.line = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
      }
    }

    return result.build();
  }
}

class _$TextDocumentIdentifierSerializer
    implements StructuredSerializer<TextDocumentIdentifier> {
  @override
  final Iterable<Type> types = const [
    TextDocumentIdentifier,
    _$TextDocumentIdentifier
  ];
  @override
  final String wireName = 'TextDocumentIdentifier';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, TextDocumentIdentifier object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.uri;
    if (value != null) {
      result
        ..add('uri')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  TextDocumentIdentifier deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new TextDocumentIdentifierBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'uri':
          result.uri = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$CompletionListSerializer
    implements StructuredSerializer<CompletionList> {
  @override
  final Iterable<Type> types = const [CompletionList, _$CompletionList];
  @override
  final String wireName = 'CompletionList';

  @override
  Iterable<Object?> serialize(Serializers serializers, CompletionList object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.isIncomplete;
    if (value != null) {
      result
        ..add('isIncomplete')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    value = object.items;
    if (value != null) {
      result
        ..add('items')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(CompletionItem)])));
    }
    return result;
  }

  @override
  CompletionList deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CompletionListBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'isIncomplete':
          result.isIncomplete = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
        case 'items':
          result.items.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(CompletionItem)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$CompletionItemSerializer
    implements StructuredSerializer<CompletionItem> {
  @override
  final Iterable<Type> types = const [CompletionItem, _$CompletionItem];
  @override
  final String wireName = 'CompletionItem';

  @override
  Iterable<Object?> serialize(Serializers serializers, CompletionItem object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.additionalTextEdits;
    if (value != null) {
      result
        ..add('additionalTextEdits')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(TextEdit)])));
    }
    value = object.command;
    if (value != null) {
      result
        ..add('command')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Command)));
    }
    value = object.data;
    if (value != null) {
      result
        ..add('data')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(BuiltMap,
                const [const FullType(dynamic), const FullType(dynamic)])));
    }
    value = object.detail;
    if (value != null) {
      result
        ..add('detail')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.documentation;
    if (value != null) {
      result
        ..add('documentation')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.filterText;
    if (value != null) {
      result
        ..add('filterText')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.insertText;
    if (value != null) {
      result
        ..add('insertText')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.insertTextFormat;
    if (value != null) {
      result
        ..add('insertTextFormat')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(InsertTextFormat)));
    }
    value = object.kind;
    if (value != null) {
      result
        ..add('kind')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(CompletionItemKind)));
    }
    value = object.label;
    if (value != null) {
      result
        ..add('label')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.sortText;
    if (value != null) {
      result
        ..add('sortText')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.textEdit;
    if (value != null) {
      result
        ..add('textEdit')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(TextEdit)));
    }
    return result;
  }

  @override
  CompletionItem deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CompletionItemBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'additionalTextEdits':
          result.additionalTextEdits.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(TextEdit)]))!
              as BuiltList<Object?>);
          break;
        case 'command':
          result.command.replace(serializers.deserialize(value,
              specifiedType: const FullType(Command))! as Command);
          break;
        case 'data':
          result.data.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltMap,
                  const [const FullType(dynamic), const FullType(dynamic)]))!);
          break;
        case 'detail':
          result.detail = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'documentation':
          result.documentation = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'filterText':
          result.filterText = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'insertText':
          result.insertText = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'insertTextFormat':
          result.insertTextFormat = serializers.deserialize(value,
                  specifiedType: const FullType(InsertTextFormat))
              as InsertTextFormat?;
          break;
        case 'kind':
          result.kind = serializers.deserialize(value,
                  specifiedType: const FullType(CompletionItemKind))
              as CompletionItemKind?;
          break;
        case 'label':
          result.label = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'sortText':
          result.sortText = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'textEdit':
          result.textEdit.replace(serializers.deserialize(value,
              specifiedType: const FullType(TextEdit))! as TextEdit);
          break;
      }
    }

    return result.build();
  }
}

class _$TextEditSerializer implements StructuredSerializer<TextEdit> {
  @override
  final Iterable<Type> types = const [TextEdit, _$TextEdit];
  @override
  final String wireName = 'TextEdit';

  @override
  Iterable<Object?> serialize(Serializers serializers, TextEdit object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.newText;
    if (value != null) {
      result
        ..add('newText')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.range;
    if (value != null) {
      result
        ..add('range')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(Range)));
    }
    return result;
  }

  @override
  TextEdit deserialize(Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new TextEditBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'newText':
          result.newText = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'range':
          result.range.replace(serializers.deserialize(value,
              specifiedType: const FullType(Range))! as Range);
          break;
      }
    }

    return result.build();
  }
}

class _$CommandSerializer implements StructuredSerializer<Command> {
  @override
  final Iterable<Type> types = const [Command, _$Command];
  @override
  final String wireName = 'Command';

  @override
  Iterable<Object?> serialize(Serializers serializers, Command object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.arguments;
    if (value != null) {
      result
        ..add('arguments')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(dynamic)])));
    }
    value = object.command;
    if (value != null) {
      result
        ..add('command')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.title;
    if (value != null) {
      result
        ..add('title')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Command deserialize(Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CommandBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'arguments':
          result.arguments.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(dynamic)]))!
              as BuiltList<Object?>);
          break;
        case 'command':
          result.command = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'title':
          result.title = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$InsertTextFormatSerializer
    implements PrimitiveSerializer<InsertTextFormat> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'plainText': 1,
    'snippet': 2,
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    1: 'plainText',
    2: 'snippet',
  };

  @override
  final Iterable<Type> types = const <Type>[InsertTextFormat];
  @override
  final String wireName = 'InsertTextFormat';

  @override
  Object serialize(Serializers serializers, InsertTextFormat object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  InsertTextFormat deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      InsertTextFormat.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$CompletionItemKindSerializer
    implements PrimitiveSerializer<CompletionItemKind> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'classKind': 7,
    'color': 16,
    'constructor': 4,
    'enumKind': 13,
    'field': 5,
    'file': 17,
    'function': 3,
    'interface': 8,
    'keyword': 14,
    'method': 2,
    'module': 9,
    'property': 10,
    'reference': 18,
    'snippet': 15,
    'text': 1,
    'unit': 11,
    'value': 12,
    'variable': 6,
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    7: 'classKind',
    16: 'color',
    4: 'constructor',
    13: 'enumKind',
    5: 'field',
    17: 'file',
    3: 'function',
    8: 'interface',
    14: 'keyword',
    2: 'method',
    9: 'module',
    10: 'property',
    18: 'reference',
    15: 'snippet',
    1: 'text',
    11: 'unit',
    12: 'value',
    6: 'variable',
  };

  @override
  final Iterable<Type> types = const <Type>[CompletionItemKind];
  @override
  final String wireName = 'CompletionItemKind';

  @override
  Object serialize(Serializers serializers, CompletionItemKind object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  CompletionItemKind deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      CompletionItemKind.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$LocationSerializer implements StructuredSerializer<Location> {
  @override
  final Iterable<Type> types = const [Location, _$Location];
  @override
  final String wireName = 'Location';

  @override
  Iterable<Object?> serialize(Serializers serializers, Location object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.range;
    if (value != null) {
      result
        ..add('range')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(Range)));
    }
    value = object.uri;
    if (value != null) {
      result
        ..add('uri')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Location deserialize(Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new LocationBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'range':
          result.range.replace(serializers.deserialize(value,
              specifiedType: const FullType(Range))! as Range);
          break;
        case 'uri':
          result.uri = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$ReferenceContextSerializer
    implements StructuredSerializer<ReferenceContext> {
  @override
  final Iterable<Type> types = const [ReferenceContext, _$ReferenceContext];
  @override
  final String wireName = 'ReferenceContext';

  @override
  Iterable<Object?> serialize(Serializers serializers, ReferenceContext object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.includeDeclaration;
    if (value != null) {
      result
        ..add('includeDeclaration')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  ReferenceContext deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new ReferenceContextBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'includeDeclaration':
          result.includeDeclaration = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool?;
          break;
      }
    }

    return result.build();
  }
}

class _$DocumentHighlightSerializer
    implements StructuredSerializer<DocumentHighlight> {
  @override
  final Iterable<Type> types = const [DocumentHighlight, _$DocumentHighlight];
  @override
  final String wireName = 'DocumentHighlight';

  @override
  Iterable<Object?> serialize(Serializers serializers, DocumentHighlight object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.kind;
    if (value != null) {
      result
        ..add('kind')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(DocumentHighlightKind)));
    }
    value = object.range;
    if (value != null) {
      result
        ..add('range')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(Range)));
    }
    return result;
  }

  @override
  DocumentHighlight deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new DocumentHighlightBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'kind':
          result.kind = serializers.deserialize(value,
                  specifiedType: const FullType(DocumentHighlightKind))
              as DocumentHighlightKind?;
          break;
        case 'range':
          result.range.replace(serializers.deserialize(value,
              specifiedType: const FullType(Range))! as Range);
          break;
      }
    }

    return result.build();
  }
}

class _$DocumentHighlightKindSerializer
    implements PrimitiveSerializer<DocumentHighlightKind> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'read': 2,
    'text': 1,
    'write': 3,
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    2: 'read',
    1: 'text',
    3: 'write',
  };

  @override
  final Iterable<Type> types = const <Type>[DocumentHighlightKind];
  @override
  final String wireName = 'DocumentHighlightKind';

  @override
  Object serialize(Serializers serializers, DocumentHighlightKind object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  DocumentHighlightKind deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      DocumentHighlightKind.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$SymbolInformationSerializer
    implements StructuredSerializer<SymbolInformation> {
  @override
  final Iterable<Type> types = const [SymbolInformation, _$SymbolInformation];
  @override
  final String wireName = 'SymbolInformation';

  @override
  Iterable<Object?> serialize(Serializers serializers, SymbolInformation object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.containerName;
    if (value != null) {
      result
        ..add('containerName')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.kind;
    if (value != null) {
      result
        ..add('kind')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(SymbolKind)));
    }
    value = object.location;
    if (value != null) {
      result
        ..add('location')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Location)));
    }
    value = object.name;
    if (value != null) {
      result
        ..add('name')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  SymbolInformation deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new SymbolInformationBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'containerName':
          result.containerName = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'kind':
          result.kind = serializers.deserialize(value,
              specifiedType: const FullType(SymbolKind)) as SymbolKind?;
          break;
        case 'location':
          result.location.replace(serializers.deserialize(value,
              specifiedType: const FullType(Location))! as Location);
          break;
        case 'name':
          result.name = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$SymbolKindSerializer implements PrimitiveSerializer<SymbolKind> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'array': 18,
    'boolean': 17,
    'classSymbol': 5,
    'constant': 14,
    'constructor': 9,
    'enumMember': 22,
    'enumSymbol': 10,
    'event': 24,
    'field': 8,
    'file': 1,
    'function': 12,
    'interface': 11,
    'key': 20,
    'method': 6,
    'module': 2,
    'namespace': 3,
    'nullSymbol': 21,
    'number': 16,
    'object': 19,
    'operator': 25,
    'package': 4,
    'property': 7,
    'string': 15,
    'struct': 23,
    'typeParameter': 26,
    'variable': 13,
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    18: 'array',
    17: 'boolean',
    5: 'classSymbol',
    14: 'constant',
    9: 'constructor',
    22: 'enumMember',
    10: 'enumSymbol',
    24: 'event',
    8: 'field',
    1: 'file',
    12: 'function',
    11: 'interface',
    20: 'key',
    6: 'method',
    2: 'module',
    3: 'namespace',
    21: 'nullSymbol',
    16: 'number',
    19: 'object',
    25: 'operator',
    4: 'package',
    7: 'property',
    15: 'string',
    23: 'struct',
    26: 'typeParameter',
    13: 'variable',
  };

  @override
  final Iterable<Type> types = const <Type>[SymbolKind];
  @override
  final String wireName = 'SymbolKind';

  @override
  Object serialize(Serializers serializers, SymbolKind object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  SymbolKind deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      SymbolKind.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$CodeActionContextSerializer
    implements StructuredSerializer<CodeActionContext> {
  @override
  final Iterable<Type> types = const [CodeActionContext, _$CodeActionContext];
  @override
  final String wireName = 'CodeActionContext';

  @override
  Iterable<Object?> serialize(Serializers serializers, CodeActionContext object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.diagnostics;
    if (value != null) {
      result
        ..add('diagnostics')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(Diagnostic)])));
    }
    return result;
  }

  @override
  CodeActionContext deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new CodeActionContextBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'diagnostics':
          result.diagnostics.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Diagnostic)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$DiagnosticSerializer implements StructuredSerializer<Diagnostic> {
  @override
  final Iterable<Type> types = const [Diagnostic, _$Diagnostic];
  @override
  final String wireName = 'Diagnostic';

  @override
  Iterable<Object?> serialize(Serializers serializers, Diagnostic object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.code;
    if (value != null) {
      result
        ..add('code')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(Object)));
    }
    value = object.message;
    if (value != null) {
      result
        ..add('message')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.range;
    if (value != null) {
      result
        ..add('range')
        ..add(
            serializers.serialize(value, specifiedType: const FullType(Range)));
    }
    value = object.severity;
    if (value != null) {
      result
        ..add('severity')
        ..add(serializers.serialize(value, specifiedType: const FullType(int)));
    }
    value = object.source;
    if (value != null) {
      result
        ..add('source')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Diagnostic deserialize(Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new DiagnosticBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'code':
          result.code = serializers.deserialize(value,
              specifiedType: const FullType(Object));
          break;
        case 'message':
          result.message = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'range':
          result.range.replace(serializers.deserialize(value,
              specifiedType: const FullType(Range))! as Range);
          break;
        case 'severity':
          result.severity = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int?;
          break;
        case 'source':
          result.source = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$WorkspaceEditSerializer implements StructuredSerializer<WorkspaceEdit> {
  @override
  final Iterable<Type> types = const [WorkspaceEdit, _$WorkspaceEdit];
  @override
  final String wireName = 'WorkspaceEdit';

  @override
  Iterable<Object?> serialize(Serializers serializers, WorkspaceEdit object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.changes;
    if (value != null) {
      result
        ..add('changes')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(BuiltMap, const [
              const FullType(String),
              const FullType(BuiltList, const [const FullType(TextEdit)])
            ])));
    }
    return result;
  }

  @override
  WorkspaceEdit deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new WorkspaceEditBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'changes':
          result.changes.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltMap, const [
                const FullType(String),
                const FullType(BuiltList, const [const FullType(TextEdit)])
              ]))!);
          break;
      }
    }

    return result.build();
  }
}

class _$DiagnosticsSerializer implements StructuredSerializer<Diagnostics> {
  @override
  final Iterable<Type> types = const [Diagnostics, _$Diagnostics];
  @override
  final String wireName = 'Diagnostics';

  @override
  Iterable<Object?> serialize(Serializers serializers, Diagnostics object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.diagnostics;
    if (value != null) {
      result
        ..add('diagnostics')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(Diagnostic)])));
    }
    value = object.uri;
    if (value != null) {
      result
        ..add('uri')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  Diagnostics deserialize(Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new DiagnosticsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'diagnostics':
          result.diagnostics.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(Diagnostic)]))!
              as BuiltList<Object?>);
          break;
        case 'uri':
          result.uri = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$ApplyWorkspaceEditParamsSerializer
    implements StructuredSerializer<ApplyWorkspaceEditParams> {
  @override
  final Iterable<Type> types = const [
    ApplyWorkspaceEditParams,
    _$ApplyWorkspaceEditParams
  ];
  @override
  final String wireName = 'ApplyWorkspaceEditParams';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, ApplyWorkspaceEditParams object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.edit;
    if (value != null) {
      result
        ..add('edit')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(WorkspaceEdit)));
    }
    value = object.label;
    if (value != null) {
      result
        ..add('label')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  ApplyWorkspaceEditParams deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new ApplyWorkspaceEditParamsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'edit':
          result.edit.replace(serializers.deserialize(value,
              specifiedType: const FullType(WorkspaceEdit))! as WorkspaceEdit);
          break;
        case 'label':
          result.label = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$ShowMessageParamsSerializer
    implements StructuredSerializer<ShowMessageParams> {
  @override
  final Iterable<Type> types = const [ShowMessageParams, _$ShowMessageParams];
  @override
  final String wireName = 'ShowMessageParams';

  @override
  Iterable<Object?> serialize(Serializers serializers, ShowMessageParams object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.message;
    if (value != null) {
      result
        ..add('message')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.type;
    if (value != null) {
      result
        ..add('type')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(MessageType)));
    }
    return result;
  }

  @override
  ShowMessageParams deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new ShowMessageParamsBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'message':
          result.message = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'type':
          result.type = serializers.deserialize(value,
              specifiedType: const FullType(MessageType)) as MessageType?;
          break;
      }
    }

    return result.build();
  }
}

class _$MessageTypeSerializer implements PrimitiveSerializer<MessageType> {
  static const Map<String, Object> _toWire = const <String, Object>{
    'error': 1,
    'info': 3,
    'log': 4,
    'warning': 2,
  };
  static const Map<Object, String> _fromWire = const <Object, String>{
    1: 'error',
    3: 'info',
    4: 'log',
    2: 'warning',
  };

  @override
  final Iterable<Type> types = const <Type>[MessageType];
  @override
  final String wireName = 'MessageType';

  @override
  Object serialize(Serializers serializers, MessageType object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  MessageType deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      MessageType.valueOf(
          _fromWire[serialized] ?? (serialized is String ? serialized : ''));
}

class _$ServerCapabilities extends ServerCapabilities {
  @override
  final bool? codeActionProvider;
  @override
  final CodeLensOptions? codeLensProvider;
  @override
  final CompletionOptions? completionProvider;
  @override
  final bool? definitionProvider;
  @override
  final bool? documentFormattingProvider;
  @override
  final bool? documentHighlightProvider;
  @override
  final DocumentLinkOptions? documentLinkProvider;
  @override
  final DocumentOnTypeFormattingOptions? documentOnTypeFormattingProvider;
  @override
  final bool? documentRangeFormattingProvider;
  @override
  final bool? documentSymbolProvider;
  @override
  final ExecuteCommandOptions? executeCommandProvider;
  @override
  final bool? hoverProvider;
  @override
  final bool? implementationProvider;
  @override
  final bool? referencesProvider;
  @override
  final bool? renameProvider;
  @override
  final SignatureHelpOptions? signatureHelpProvider;
  @override
  final TextDocumentSyncOptions? textDocumentSync;
  @override
  final bool? workspaceSymbolProvider;

  factory _$ServerCapabilities(
          [void Function(ServerCapabilitiesBuilder)? updates]) =>
      (new ServerCapabilitiesBuilder()..update(updates)).build();

  _$ServerCapabilities._(
      {this.codeActionProvider,
      this.codeLensProvider,
      this.completionProvider,
      this.definitionProvider,
      this.documentFormattingProvider,
      this.documentHighlightProvider,
      this.documentLinkProvider,
      this.documentOnTypeFormattingProvider,
      this.documentRangeFormattingProvider,
      this.documentSymbolProvider,
      this.executeCommandProvider,
      this.hoverProvider,
      this.implementationProvider,
      this.referencesProvider,
      this.renameProvider,
      this.signatureHelpProvider,
      this.textDocumentSync,
      this.workspaceSymbolProvider})
      : super._();

  @override
  ServerCapabilities rebuild(
          void Function(ServerCapabilitiesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  ServerCapabilitiesBuilder toBuilder() =>
      new ServerCapabilitiesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ServerCapabilities &&
        codeActionProvider == other.codeActionProvider &&
        codeLensProvider == other.codeLensProvider &&
        completionProvider == other.completionProvider &&
        definitionProvider == other.definitionProvider &&
        documentFormattingProvider == other.documentFormattingProvider &&
        documentHighlightProvider == other.documentHighlightProvider &&
        documentLinkProvider == other.documentLinkProvider &&
        documentOnTypeFormattingProvider ==
            other.documentOnTypeFormattingProvider &&
        documentRangeFormattingProvider ==
            other.documentRangeFormattingProvider &&
        documentSymbolProvider == other.documentSymbolProvider &&
        executeCommandProvider == other.executeCommandProvider &&
        hoverProvider == other.hoverProvider &&
        implementationProvider == other.implementationProvider &&
        referencesProvider == other.referencesProvider &&
        renameProvider == other.renameProvider &&
        signatureHelpProvider == other.signatureHelpProvider &&
        textDocumentSync == other.textDocumentSync &&
        workspaceSymbolProvider == other.workspaceSymbolProvider;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc(
                            $jc(
                                $jc(
                                    $jc(
                                        $jc(
                                            $jc(
                                                $jc(
                                                    $jc(
                                                        $jc(
                                                            $jc(
                                                                $jc(
                                                                    $jc(
                                                                        $jc(
                                                                            0,
                                                                            codeActionProvider
                                                                                .hashCode),
                                                                        codeLensProvider
                                                                            .hashCode),
                                                                    completionProvider
                                                                        .hashCode),
                                                                definitionProvider
                                                                    .hashCode),
                                                            documentFormattingProvider
                                                                .hashCode),
                                                        documentHighlightProvider
                                                            .hashCode),
                                                    documentLinkProvider
                                                        .hashCode),
                                                documentOnTypeFormattingProvider
                                                    .hashCode),
                                            documentRangeFormattingProvider
                                                .hashCode),
                                        documentSymbolProvider.hashCode),
                                    executeCommandProvider.hashCode),
                                hoverProvider.hashCode),
                            implementationProvider.hashCode),
                        referencesProvider.hashCode),
                    renameProvider.hashCode),
                signatureHelpProvider.hashCode),
            textDocumentSync.hashCode),
        workspaceSymbolProvider.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('ServerCapabilities')
          ..add('codeActionProvider', codeActionProvider)
          ..add('codeLensProvider', codeLensProvider)
          ..add('completionProvider', completionProvider)
          ..add('definitionProvider', definitionProvider)
          ..add('documentFormattingProvider', documentFormattingProvider)
          ..add('documentHighlightProvider', documentHighlightProvider)
          ..add('documentLinkProvider', documentLinkProvider)
          ..add('documentOnTypeFormattingProvider',
              documentOnTypeFormattingProvider)
          ..add('documentRangeFormattingProvider',
              documentRangeFormattingProvider)
          ..add('documentSymbolProvider', documentSymbolProvider)
          ..add('executeCommandProvider', executeCommandProvider)
          ..add('hoverProvider', hoverProvider)
          ..add('implementationProvider', implementationProvider)
          ..add('referencesProvider', referencesProvider)
          ..add('renameProvider', renameProvider)
          ..add('signatureHelpProvider', signatureHelpProvider)
          ..add('textDocumentSync', textDocumentSync)
          ..add('workspaceSymbolProvider', workspaceSymbolProvider))
        .toString();
  }
}

class ServerCapabilitiesBuilder
    implements Builder<ServerCapabilities, ServerCapabilitiesBuilder> {
  _$ServerCapabilities? _$v;

  bool? _codeActionProvider;
  bool? get codeActionProvider => _$this._codeActionProvider;
  set codeActionProvider(bool? codeActionProvider) =>
      _$this._codeActionProvider = codeActionProvider;

  CodeLensOptionsBuilder? _codeLensProvider;
  CodeLensOptionsBuilder get codeLensProvider =>
      _$this._codeLensProvider ??= new CodeLensOptionsBuilder();
  set codeLensProvider(CodeLensOptionsBuilder? codeLensProvider) =>
      _$this._codeLensProvider = codeLensProvider;

  CompletionOptionsBuilder? _completionProvider;
  CompletionOptionsBuilder get completionProvider =>
      _$this._completionProvider ??= new CompletionOptionsBuilder();
  set completionProvider(CompletionOptionsBuilder? completionProvider) =>
      _$this._completionProvider = completionProvider;

  bool? _definitionProvider;
  bool? get definitionProvider => _$this._definitionProvider;
  set definitionProvider(bool? definitionProvider) =>
      _$this._definitionProvider = definitionProvider;

  bool? _documentFormattingProvider;
  bool? get documentFormattingProvider => _$this._documentFormattingProvider;
  set documentFormattingProvider(bool? documentFormattingProvider) =>
      _$this._documentFormattingProvider = documentFormattingProvider;

  bool? _documentHighlightProvider;
  bool? get documentHighlightProvider => _$this._documentHighlightProvider;
  set documentHighlightProvider(bool? documentHighlightProvider) =>
      _$this._documentHighlightProvider = documentHighlightProvider;

  DocumentLinkOptionsBuilder? _documentLinkProvider;
  DocumentLinkOptionsBuilder get documentLinkProvider =>
      _$this._documentLinkProvider ??= new DocumentLinkOptionsBuilder();
  set documentLinkProvider(DocumentLinkOptionsBuilder? documentLinkProvider) =>
      _$this._documentLinkProvider = documentLinkProvider;

  DocumentOnTypeFormattingOptionsBuilder? _documentOnTypeFormattingProvider;
  DocumentOnTypeFormattingOptionsBuilder get documentOnTypeFormattingProvider =>
      _$this._documentOnTypeFormattingProvider ??=
          new DocumentOnTypeFormattingOptionsBuilder();
  set documentOnTypeFormattingProvider(
          DocumentOnTypeFormattingOptionsBuilder?
              documentOnTypeFormattingProvider) =>
      _$this._documentOnTypeFormattingProvider =
          documentOnTypeFormattingProvider;

  bool? _documentRangeFormattingProvider;
  bool? get documentRangeFormattingProvider =>
      _$this._documentRangeFormattingProvider;
  set documentRangeFormattingProvider(bool? documentRangeFormattingProvider) =>
      _$this._documentRangeFormattingProvider = documentRangeFormattingProvider;

  bool? _documentSymbolProvider;
  bool? get documentSymbolProvider => _$this._documentSymbolProvider;
  set documentSymbolProvider(bool? documentSymbolProvider) =>
      _$this._documentSymbolProvider = documentSymbolProvider;

  ExecuteCommandOptionsBuilder? _executeCommandProvider;
  ExecuteCommandOptionsBuilder get executeCommandProvider =>
      _$this._executeCommandProvider ??= new ExecuteCommandOptionsBuilder();
  set executeCommandProvider(
          ExecuteCommandOptionsBuilder? executeCommandProvider) =>
      _$this._executeCommandProvider = executeCommandProvider;

  bool? _hoverProvider;
  bool? get hoverProvider => _$this._hoverProvider;
  set hoverProvider(bool? hoverProvider) =>
      _$this._hoverProvider = hoverProvider;

  bool? _implementationProvider;
  bool? get implementationProvider => _$this._implementationProvider;
  set implementationProvider(bool? implementationProvider) =>
      _$this._implementationProvider = implementationProvider;

  bool? _referencesProvider;
  bool? get referencesProvider => _$this._referencesProvider;
  set referencesProvider(bool? referencesProvider) =>
      _$this._referencesProvider = referencesProvider;

  bool? _renameProvider;
  bool? get renameProvider => _$this._renameProvider;
  set renameProvider(bool? renameProvider) =>
      _$this._renameProvider = renameProvider;

  SignatureHelpOptionsBuilder? _signatureHelpProvider;
  SignatureHelpOptionsBuilder get signatureHelpProvider =>
      _$this._signatureHelpProvider ??= new SignatureHelpOptionsBuilder();
  set signatureHelpProvider(
          SignatureHelpOptionsBuilder? signatureHelpProvider) =>
      _$this._signatureHelpProvider = signatureHelpProvider;

  TextDocumentSyncOptionsBuilder? _textDocumentSync;
  TextDocumentSyncOptionsBuilder get textDocumentSync =>
      _$this._textDocumentSync ??= new TextDocumentSyncOptionsBuilder();
  set textDocumentSync(TextDocumentSyncOptionsBuilder? textDocumentSync) =>
      _$this._textDocumentSync = textDocumentSync;

  bool? _workspaceSymbolProvider;
  bool? get workspaceSymbolProvider => _$this._workspaceSymbolProvider;
  set workspaceSymbolProvider(bool? workspaceSymbolProvider) =>
      _$this._workspaceSymbolProvider = workspaceSymbolProvider;

  ServerCapabilitiesBuilder();

  ServerCapabilitiesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _codeActionProvider = $v.codeActionProvider;
      _codeLensProvider = $v.codeLensProvider?.toBuilder();
      _completionProvider = $v.completionProvider?.toBuilder();
      _definitionProvider = $v.definitionProvider;
      _documentFormattingProvider = $v.documentFormattingProvider;
      _documentHighlightProvider = $v.documentHighlightProvider;
      _documentLinkProvider = $v.documentLinkProvider?.toBuilder();
      _documentOnTypeFormattingProvider =
          $v.documentOnTypeFormattingProvider?.toBuilder();
      _documentRangeFormattingProvider = $v.documentRangeFormattingProvider;
      _documentSymbolProvider = $v.documentSymbolProvider;
      _executeCommandProvider = $v.executeCommandProvider?.toBuilder();
      _hoverProvider = $v.hoverProvider;
      _implementationProvider = $v.implementationProvider;
      _referencesProvider = $v.referencesProvider;
      _renameProvider = $v.renameProvider;
      _signatureHelpProvider = $v.signatureHelpProvider?.toBuilder();
      _textDocumentSync = $v.textDocumentSync?.toBuilder();
      _workspaceSymbolProvider = $v.workspaceSymbolProvider;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(ServerCapabilities other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$ServerCapabilities;
  }

  @override
  void update(void Function(ServerCapabilitiesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$ServerCapabilities build() {
    _$ServerCapabilities _$result;
    try {
      _$result = _$v ??
          new _$ServerCapabilities._(
              codeActionProvider: codeActionProvider,
              codeLensProvider: _codeLensProvider?.build(),
              completionProvider: _completionProvider?.build(),
              definitionProvider: definitionProvider,
              documentFormattingProvider: documentFormattingProvider,
              documentHighlightProvider: documentHighlightProvider,
              documentLinkProvider: _documentLinkProvider?.build(),
              documentOnTypeFormattingProvider:
                  _documentOnTypeFormattingProvider?.build(),
              documentRangeFormattingProvider: documentRangeFormattingProvider,
              documentSymbolProvider: documentSymbolProvider,
              executeCommandProvider: _executeCommandProvider?.build(),
              hoverProvider: hoverProvider,
              implementationProvider: implementationProvider,
              referencesProvider: referencesProvider,
              renameProvider: renameProvider,
              signatureHelpProvider: _signatureHelpProvider?.build(),
              textDocumentSync: _textDocumentSync?.build(),
              workspaceSymbolProvider: workspaceSymbolProvider);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'codeLensProvider';
        _codeLensProvider?.build();
        _$failedField = 'completionProvider';
        _completionProvider?.build();

        _$failedField = 'documentLinkProvider';
        _documentLinkProvider?.build();
        _$failedField = 'documentOnTypeFormattingProvider';
        _documentOnTypeFormattingProvider?.build();

        _$failedField = 'executeCommandProvider';
        _executeCommandProvider?.build();

        _$failedField = 'signatureHelpProvider';
        _signatureHelpProvider?.build();
        _$failedField = 'textDocumentSync';
        _textDocumentSync?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'ServerCapabilities', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$ClientCapabilities extends ClientCapabilities {
  @override
  final TextDocumentClientCapabilities? textDocument;
  @override
  final WorkspaceClientCapabilities? workspace;

  factory _$ClientCapabilities(
          [void Function(ClientCapabilitiesBuilder)? updates]) =>
      (new ClientCapabilitiesBuilder()..update(updates)).build();

  _$ClientCapabilities._({this.textDocument, this.workspace}) : super._();

  @override
  ClientCapabilities rebuild(
          void Function(ClientCapabilitiesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  ClientCapabilitiesBuilder toBuilder() =>
      new ClientCapabilitiesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ClientCapabilities &&
        textDocument == other.textDocument &&
        workspace == other.workspace;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, textDocument.hashCode), workspace.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('ClientCapabilities')
          ..add('textDocument', textDocument)
          ..add('workspace', workspace))
        .toString();
  }
}

class ClientCapabilitiesBuilder
    implements Builder<ClientCapabilities, ClientCapabilitiesBuilder> {
  _$ClientCapabilities? _$v;

  TextDocumentClientCapabilitiesBuilder? _textDocument;
  TextDocumentClientCapabilitiesBuilder get textDocument =>
      _$this._textDocument ??= new TextDocumentClientCapabilitiesBuilder();
  set textDocument(TextDocumentClientCapabilitiesBuilder? textDocument) =>
      _$this._textDocument = textDocument;

  WorkspaceClientCapabilitiesBuilder? _workspace;
  WorkspaceClientCapabilitiesBuilder get workspace =>
      _$this._workspace ??= new WorkspaceClientCapabilitiesBuilder();
  set workspace(WorkspaceClientCapabilitiesBuilder? workspace) =>
      _$this._workspace = workspace;

  ClientCapabilitiesBuilder();

  ClientCapabilitiesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _textDocument = $v.textDocument?.toBuilder();
      _workspace = $v.workspace?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(ClientCapabilities other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$ClientCapabilities;
  }

  @override
  void update(void Function(ClientCapabilitiesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$ClientCapabilities build() {
    _$ClientCapabilities _$result;
    try {
      _$result = _$v ??
          new _$ClientCapabilities._(
              textDocument: _textDocument?.build(),
              workspace: _workspace?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'textDocument';
        _textDocument?.build();
        _$failedField = 'workspace';
        _workspace?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'ClientCapabilities', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$TextDocumentClientCapabilities extends TextDocumentClientCapabilities {
  @override
  final CodeActionCapabilities? codeAction;
  @override
  final DynamicRegistrationCapability? codeLens;
  @override
  final CompletionCapabilities? completion;
  @override
  final DynamicRegistrationCapability? definition;
  @override
  final DynamicRegistrationCapability? documentHighlight;
  @override
  final DynamicRegistrationCapability? documentLink;
  @override
  final DynamicRegistrationCapability? documentSymbol;
  @override
  final DynamicRegistrationCapability? formatting;
  @override
  final HoverCapabilities? hover;
  @override
  final DynamicRegistrationCapability? onTypeFormatting;
  @override
  final DynamicRegistrationCapability? references;
  @override
  final DynamicRegistrationCapability? rename;
  @override
  final SynchronizationCapabilities? synchronization;

  factory _$TextDocumentClientCapabilities(
          [void Function(TextDocumentClientCapabilitiesBuilder)? updates]) =>
      (new TextDocumentClientCapabilitiesBuilder()..update(updates)).build();

  _$TextDocumentClientCapabilities._(
      {this.codeAction,
      this.codeLens,
      this.completion,
      this.definition,
      this.documentHighlight,
      this.documentLink,
      this.documentSymbol,
      this.formatting,
      this.hover,
      this.onTypeFormatting,
      this.references,
      this.rename,
      this.synchronization})
      : super._();

  @override
  TextDocumentClientCapabilities rebuild(
          void Function(TextDocumentClientCapabilitiesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  TextDocumentClientCapabilitiesBuilder toBuilder() =>
      new TextDocumentClientCapabilitiesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TextDocumentClientCapabilities &&
        codeAction == other.codeAction &&
        codeLens == other.codeLens &&
        completion == other.completion &&
        definition == other.definition &&
        documentHighlight == other.documentHighlight &&
        documentLink == other.documentLink &&
        documentSymbol == other.documentSymbol &&
        formatting == other.formatting &&
        hover == other.hover &&
        onTypeFormatting == other.onTypeFormatting &&
        references == other.references &&
        rename == other.rename &&
        synchronization == other.synchronization;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc(
                            $jc(
                                $jc(
                                    $jc(
                                        $jc(
                                            $jc(
                                                $jc($jc(0, codeAction.hashCode),
                                                    codeLens.hashCode),
                                                completion.hashCode),
                                            definition.hashCode),
                                        documentHighlight.hashCode),
                                    documentLink.hashCode),
                                documentSymbol.hashCode),
                            formatting.hashCode),
                        hover.hashCode),
                    onTypeFormatting.hashCode),
                references.hashCode),
            rename.hashCode),
        synchronization.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('TextDocumentClientCapabilities')
          ..add('codeAction', codeAction)
          ..add('codeLens', codeLens)
          ..add('completion', completion)
          ..add('definition', definition)
          ..add('documentHighlight', documentHighlight)
          ..add('documentLink', documentLink)
          ..add('documentSymbol', documentSymbol)
          ..add('formatting', formatting)
          ..add('hover', hover)
          ..add('onTypeFormatting', onTypeFormatting)
          ..add('references', references)
          ..add('rename', rename)
          ..add('synchronization', synchronization))
        .toString();
  }
}

class TextDocumentClientCapabilitiesBuilder
    implements
        Builder<TextDocumentClientCapabilities,
            TextDocumentClientCapabilitiesBuilder> {
  _$TextDocumentClientCapabilities? _$v;

  CodeActionCapabilitiesBuilder? _codeAction;
  CodeActionCapabilitiesBuilder get codeAction =>
      _$this._codeAction ??= new CodeActionCapabilitiesBuilder();
  set codeAction(CodeActionCapabilitiesBuilder? codeAction) =>
      _$this._codeAction = codeAction;

  DynamicRegistrationCapabilityBuilder? _codeLens;
  DynamicRegistrationCapabilityBuilder get codeLens =>
      _$this._codeLens ??= new DynamicRegistrationCapabilityBuilder();
  set codeLens(DynamicRegistrationCapabilityBuilder? codeLens) =>
      _$this._codeLens = codeLens;

  CompletionCapabilitiesBuilder? _completion;
  CompletionCapabilitiesBuilder get completion =>
      _$this._completion ??= new CompletionCapabilitiesBuilder();
  set completion(CompletionCapabilitiesBuilder? completion) =>
      _$this._completion = completion;

  DynamicRegistrationCapabilityBuilder? _definition;
  DynamicRegistrationCapabilityBuilder get definition =>
      _$this._definition ??= new DynamicRegistrationCapabilityBuilder();
  set definition(DynamicRegistrationCapabilityBuilder? definition) =>
      _$this._definition = definition;

  DynamicRegistrationCapabilityBuilder? _documentHighlight;
  DynamicRegistrationCapabilityBuilder get documentHighlight =>
      _$this._documentHighlight ??= new DynamicRegistrationCapabilityBuilder();
  set documentHighlight(
          DynamicRegistrationCapabilityBuilder? documentHighlight) =>
      _$this._documentHighlight = documentHighlight;

  DynamicRegistrationCapabilityBuilder? _documentLink;
  DynamicRegistrationCapabilityBuilder get documentLink =>
      _$this._documentLink ??= new DynamicRegistrationCapabilityBuilder();
  set documentLink(DynamicRegistrationCapabilityBuilder? documentLink) =>
      _$this._documentLink = documentLink;

  DynamicRegistrationCapabilityBuilder? _documentSymbol;
  DynamicRegistrationCapabilityBuilder get documentSymbol =>
      _$this._documentSymbol ??= new DynamicRegistrationCapabilityBuilder();
  set documentSymbol(DynamicRegistrationCapabilityBuilder? documentSymbol) =>
      _$this._documentSymbol = documentSymbol;

  DynamicRegistrationCapabilityBuilder? _formatting;
  DynamicRegistrationCapabilityBuilder get formatting =>
      _$this._formatting ??= new DynamicRegistrationCapabilityBuilder();
  set formatting(DynamicRegistrationCapabilityBuilder? formatting) =>
      _$this._formatting = formatting;

  HoverCapabilitiesBuilder? _hover;
  HoverCapabilitiesBuilder get hover =>
      _$this._hover ??= new HoverCapabilitiesBuilder();
  set hover(HoverCapabilitiesBuilder? hover) => _$this._hover = hover;

  DynamicRegistrationCapabilityBuilder? _onTypeFormatting;
  DynamicRegistrationCapabilityBuilder get onTypeFormatting =>
      _$this._onTypeFormatting ??= new DynamicRegistrationCapabilityBuilder();
  set onTypeFormatting(
          DynamicRegistrationCapabilityBuilder? onTypeFormatting) =>
      _$this._onTypeFormatting = onTypeFormatting;

  DynamicRegistrationCapabilityBuilder? _references;
  DynamicRegistrationCapabilityBuilder get references =>
      _$this._references ??= new DynamicRegistrationCapabilityBuilder();
  set references(DynamicRegistrationCapabilityBuilder? references) =>
      _$this._references = references;

  DynamicRegistrationCapabilityBuilder? _rename;
  DynamicRegistrationCapabilityBuilder get rename =>
      _$this._rename ??= new DynamicRegistrationCapabilityBuilder();
  set rename(DynamicRegistrationCapabilityBuilder? rename) =>
      _$this._rename = rename;

  SynchronizationCapabilitiesBuilder? _synchronization;
  SynchronizationCapabilitiesBuilder get synchronization =>
      _$this._synchronization ??= new SynchronizationCapabilitiesBuilder();
  set synchronization(SynchronizationCapabilitiesBuilder? synchronization) =>
      _$this._synchronization = synchronization;

  TextDocumentClientCapabilitiesBuilder();

  TextDocumentClientCapabilitiesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _codeAction = $v.codeAction?.toBuilder();
      _codeLens = $v.codeLens?.toBuilder();
      _completion = $v.completion?.toBuilder();
      _definition = $v.definition?.toBuilder();
      _documentHighlight = $v.documentHighlight?.toBuilder();
      _documentLink = $v.documentLink?.toBuilder();
      _documentSymbol = $v.documentSymbol?.toBuilder();
      _formatting = $v.formatting?.toBuilder();
      _hover = $v.hover?.toBuilder();
      _onTypeFormatting = $v.onTypeFormatting?.toBuilder();
      _references = $v.references?.toBuilder();
      _rename = $v.rename?.toBuilder();
      _synchronization = $v.synchronization?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(TextDocumentClientCapabilities other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$TextDocumentClientCapabilities;
  }

  @override
  void update(void Function(TextDocumentClientCapabilitiesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$TextDocumentClientCapabilities build() {
    _$TextDocumentClientCapabilities _$result;
    try {
      _$result = _$v ??
          new _$TextDocumentClientCapabilities._(
              codeAction: _codeAction?.build(),
              codeLens: _codeLens?.build(),
              completion: _completion?.build(),
              definition: _definition?.build(),
              documentHighlight: _documentHighlight?.build(),
              documentLink: _documentLink?.build(),
              documentSymbol: _documentSymbol?.build(),
              formatting: _formatting?.build(),
              hover: _hover?.build(),
              onTypeFormatting: _onTypeFormatting?.build(),
              references: _references?.build(),
              rename: _rename?.build(),
              synchronization: _synchronization?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'codeAction';
        _codeAction?.build();
        _$failedField = 'codeLens';
        _codeLens?.build();
        _$failedField = 'completion';
        _completion?.build();
        _$failedField = 'definition';
        _definition?.build();
        _$failedField = 'documentHighlight';
        _documentHighlight?.build();
        _$failedField = 'documentLink';
        _documentLink?.build();
        _$failedField = 'documentSymbol';
        _documentSymbol?.build();
        _$failedField = 'formatting';
        _formatting?.build();
        _$failedField = 'hover';
        _hover?.build();
        _$failedField = 'onTypeFormatting';
        _onTypeFormatting?.build();
        _$failedField = 'references';
        _references?.build();
        _$failedField = 'rename';
        _rename?.build();
        _$failedField = 'synchronization';
        _synchronization?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'TextDocumentClientCapabilities', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$SynchronizationCapabilities extends SynchronizationCapabilities {
  @override
  final bool? didSave;
  @override
  final bool? dynamicRegistration;
  @override
  final bool? willSave;
  @override
  final bool? willSaveWaitUntil;

  factory _$SynchronizationCapabilities(
          [void Function(SynchronizationCapabilitiesBuilder)? updates]) =>
      (new SynchronizationCapabilitiesBuilder()..update(updates)).build();

  _$SynchronizationCapabilities._(
      {this.didSave,
      this.dynamicRegistration,
      this.willSave,
      this.willSaveWaitUntil})
      : super._();

  @override
  SynchronizationCapabilities rebuild(
          void Function(SynchronizationCapabilitiesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  SynchronizationCapabilitiesBuilder toBuilder() =>
      new SynchronizationCapabilitiesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SynchronizationCapabilities &&
        didSave == other.didSave &&
        dynamicRegistration == other.dynamicRegistration &&
        willSave == other.willSave &&
        willSaveWaitUntil == other.willSaveWaitUntil;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc($jc($jc(0, didSave.hashCode), dynamicRegistration.hashCode),
            willSave.hashCode),
        willSaveWaitUntil.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('SynchronizationCapabilities')
          ..add('didSave', didSave)
          ..add('dynamicRegistration', dynamicRegistration)
          ..add('willSave', willSave)
          ..add('willSaveWaitUntil', willSaveWaitUntil))
        .toString();
  }
}

class SynchronizationCapabilitiesBuilder
    implements
        Builder<SynchronizationCapabilities,
            SynchronizationCapabilitiesBuilder> {
  _$SynchronizationCapabilities? _$v;

  bool? _didSave;
  bool? get didSave => _$this._didSave;
  set didSave(bool? didSave) => _$this._didSave = didSave;

  bool? _dynamicRegistration;
  bool? get dynamicRegistration => _$this._dynamicRegistration;
  set dynamicRegistration(bool? dynamicRegistration) =>
      _$this._dynamicRegistration = dynamicRegistration;

  bool? _willSave;
  bool? get willSave => _$this._willSave;
  set willSave(bool? willSave) => _$this._willSave = willSave;

  bool? _willSaveWaitUntil;
  bool? get willSaveWaitUntil => _$this._willSaveWaitUntil;
  set willSaveWaitUntil(bool? willSaveWaitUntil) =>
      _$this._willSaveWaitUntil = willSaveWaitUntil;

  SynchronizationCapabilitiesBuilder();

  SynchronizationCapabilitiesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _didSave = $v.didSave;
      _dynamicRegistration = $v.dynamicRegistration;
      _willSave = $v.willSave;
      _willSaveWaitUntil = $v.willSaveWaitUntil;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(SynchronizationCapabilities other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$SynchronizationCapabilities;
  }

  @override
  void update(void Function(SynchronizationCapabilitiesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$SynchronizationCapabilities build() {
    final _$result = _$v ??
        new _$SynchronizationCapabilities._(
            didSave: didSave,
            dynamicRegistration: dynamicRegistration,
            willSave: willSave,
            willSaveWaitUntil: willSaveWaitUntil);
    replace(_$result);
    return _$result;
  }
}

class _$HoverCapabilities extends HoverCapabilities {
  @override
  final BuiltList<String>? contentFormat;
  @override
  final bool? dynamicRegistration;

  factory _$HoverCapabilities(
          [void Function(HoverCapabilitiesBuilder)? updates]) =>
      (new HoverCapabilitiesBuilder()..update(updates)).build();

  _$HoverCapabilities._({this.contentFormat, this.dynamicRegistration})
      : super._();

  @override
  HoverCapabilities rebuild(void Function(HoverCapabilitiesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  HoverCapabilitiesBuilder toBuilder() =>
      new HoverCapabilitiesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is HoverCapabilities &&
        contentFormat == other.contentFormat &&
        dynamicRegistration == other.dynamicRegistration;
  }

  @override
  int get hashCode {
    return $jf(
        $jc($jc(0, contentFormat.hashCode), dynamicRegistration.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('HoverCapabilities')
          ..add('contentFormat', contentFormat)
          ..add('dynamicRegistration', dynamicRegistration))
        .toString();
  }
}

class HoverCapabilitiesBuilder
    implements Builder<HoverCapabilities, HoverCapabilitiesBuilder> {
  _$HoverCapabilities? _$v;

  ListBuilder<String>? _contentFormat;
  ListBuilder<String> get contentFormat =>
      _$this._contentFormat ??= new ListBuilder<String>();
  set contentFormat(ListBuilder<String>? contentFormat) =>
      _$this._contentFormat = contentFormat;

  bool? _dynamicRegistration;
  bool? get dynamicRegistration => _$this._dynamicRegistration;
  set dynamicRegistration(bool? dynamicRegistration) =>
      _$this._dynamicRegistration = dynamicRegistration;

  HoverCapabilitiesBuilder();

  HoverCapabilitiesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _contentFormat = $v.contentFormat?.toBuilder();
      _dynamicRegistration = $v.dynamicRegistration;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(HoverCapabilities other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$HoverCapabilities;
  }

  @override
  void update(void Function(HoverCapabilitiesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$HoverCapabilities build() {
    _$HoverCapabilities _$result;
    try {
      _$result = _$v ??
          new _$HoverCapabilities._(
              contentFormat: _contentFormat?.build(),
              dynamicRegistration: dynamicRegistration);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'contentFormat';
        _contentFormat?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'HoverCapabilities', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$WorkspaceClientCapabilities extends WorkspaceClientCapabilities {
  @override
  final bool? applyEdit;
  @override
  final DynamicRegistrationCapability? didChangeConfiguration;
  @override
  final DynamicRegistrationCapability? didChangeWatchedFiles;
  @override
  final DynamicRegistrationCapability? executeCommand;
  @override
  final DynamicRegistrationCapability? symbol;

  factory _$WorkspaceClientCapabilities(
          [void Function(WorkspaceClientCapabilitiesBuilder)? updates]) =>
      (new WorkspaceClientCapabilitiesBuilder()..update(updates)).build();

  _$WorkspaceClientCapabilities._(
      {this.applyEdit,
      this.didChangeConfiguration,
      this.didChangeWatchedFiles,
      this.executeCommand,
      this.symbol})
      : super._();

  @override
  WorkspaceClientCapabilities rebuild(
          void Function(WorkspaceClientCapabilitiesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  WorkspaceClientCapabilitiesBuilder toBuilder() =>
      new WorkspaceClientCapabilitiesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is WorkspaceClientCapabilities &&
        applyEdit == other.applyEdit &&
        didChangeConfiguration == other.didChangeConfiguration &&
        didChangeWatchedFiles == other.didChangeWatchedFiles &&
        executeCommand == other.executeCommand &&
        symbol == other.symbol;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc($jc(0, applyEdit.hashCode),
                    didChangeConfiguration.hashCode),
                didChangeWatchedFiles.hashCode),
            executeCommand.hashCode),
        symbol.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('WorkspaceClientCapabilities')
          ..add('applyEdit', applyEdit)
          ..add('didChangeConfiguration', didChangeConfiguration)
          ..add('didChangeWatchedFiles', didChangeWatchedFiles)
          ..add('executeCommand', executeCommand)
          ..add('symbol', symbol))
        .toString();
  }
}

class WorkspaceClientCapabilitiesBuilder
    implements
        Builder<WorkspaceClientCapabilities,
            WorkspaceClientCapabilitiesBuilder> {
  _$WorkspaceClientCapabilities? _$v;

  bool? _applyEdit;
  bool? get applyEdit => _$this._applyEdit;
  set applyEdit(bool? applyEdit) => _$this._applyEdit = applyEdit;

  DynamicRegistrationCapabilityBuilder? _didChangeConfiguration;
  DynamicRegistrationCapabilityBuilder get didChangeConfiguration =>
      _$this._didChangeConfiguration ??=
          new DynamicRegistrationCapabilityBuilder();
  set didChangeConfiguration(
          DynamicRegistrationCapabilityBuilder? didChangeConfiguration) =>
      _$this._didChangeConfiguration = didChangeConfiguration;

  DynamicRegistrationCapabilityBuilder? _didChangeWatchedFiles;
  DynamicRegistrationCapabilityBuilder get didChangeWatchedFiles =>
      _$this._didChangeWatchedFiles ??=
          new DynamicRegistrationCapabilityBuilder();
  set didChangeWatchedFiles(
          DynamicRegistrationCapabilityBuilder? didChangeWatchedFiles) =>
      _$this._didChangeWatchedFiles = didChangeWatchedFiles;

  DynamicRegistrationCapabilityBuilder? _executeCommand;
  DynamicRegistrationCapabilityBuilder get executeCommand =>
      _$this._executeCommand ??= new DynamicRegistrationCapabilityBuilder();
  set executeCommand(DynamicRegistrationCapabilityBuilder? executeCommand) =>
      _$this._executeCommand = executeCommand;

  DynamicRegistrationCapabilityBuilder? _symbol;
  DynamicRegistrationCapabilityBuilder get symbol =>
      _$this._symbol ??= new DynamicRegistrationCapabilityBuilder();
  set symbol(DynamicRegistrationCapabilityBuilder? symbol) =>
      _$this._symbol = symbol;

  WorkspaceClientCapabilitiesBuilder();

  WorkspaceClientCapabilitiesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _applyEdit = $v.applyEdit;
      _didChangeConfiguration = $v.didChangeConfiguration?.toBuilder();
      _didChangeWatchedFiles = $v.didChangeWatchedFiles?.toBuilder();
      _executeCommand = $v.executeCommand?.toBuilder();
      _symbol = $v.symbol?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(WorkspaceClientCapabilities other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$WorkspaceClientCapabilities;
  }

  @override
  void update(void Function(WorkspaceClientCapabilitiesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$WorkspaceClientCapabilities build() {
    _$WorkspaceClientCapabilities _$result;
    try {
      _$result = _$v ??
          new _$WorkspaceClientCapabilities._(
              applyEdit: applyEdit,
              didChangeConfiguration: _didChangeConfiguration?.build(),
              didChangeWatchedFiles: _didChangeWatchedFiles?.build(),
              executeCommand: _executeCommand?.build(),
              symbol: _symbol?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'didChangeConfiguration';
        _didChangeConfiguration?.build();
        _$failedField = 'didChangeWatchedFiles';
        _didChangeWatchedFiles?.build();
        _$failedField = 'executeCommand';
        _executeCommand?.build();
        _$failedField = 'symbol';
        _symbol?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'WorkspaceClientCapabilities', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$DynamicRegistrationCapability extends DynamicRegistrationCapability {
  @override
  final bool? dynamicRegistration;

  factory _$DynamicRegistrationCapability(
          [void Function(DynamicRegistrationCapabilityBuilder)? updates]) =>
      (new DynamicRegistrationCapabilityBuilder()..update(updates)).build();

  _$DynamicRegistrationCapability._({this.dynamicRegistration}) : super._();

  @override
  DynamicRegistrationCapability rebuild(
          void Function(DynamicRegistrationCapabilityBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  DynamicRegistrationCapabilityBuilder toBuilder() =>
      new DynamicRegistrationCapabilityBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is DynamicRegistrationCapability &&
        dynamicRegistration == other.dynamicRegistration;
  }

  @override
  int get hashCode {
    return $jf($jc(0, dynamicRegistration.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('DynamicRegistrationCapability')
          ..add('dynamicRegistration', dynamicRegistration))
        .toString();
  }
}

class DynamicRegistrationCapabilityBuilder
    implements
        Builder<DynamicRegistrationCapability,
            DynamicRegistrationCapabilityBuilder> {
  _$DynamicRegistrationCapability? _$v;

  bool? _dynamicRegistration;
  bool? get dynamicRegistration => _$this._dynamicRegistration;
  set dynamicRegistration(bool? dynamicRegistration) =>
      _$this._dynamicRegistration = dynamicRegistration;

  DynamicRegistrationCapabilityBuilder();

  DynamicRegistrationCapabilityBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _dynamicRegistration = $v.dynamicRegistration;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(DynamicRegistrationCapability other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$DynamicRegistrationCapability;
  }

  @override
  void update(void Function(DynamicRegistrationCapabilityBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$DynamicRegistrationCapability build() {
    final _$result = _$v ??
        new _$DynamicRegistrationCapability._(
            dynamicRegistration: dynamicRegistration);
    replace(_$result);
    return _$result;
  }
}

class _$CodeActionCapabilities extends CodeActionCapabilities {
  @override
  final CodeActionLiteralSupport? codeActionLiteralSupport;
  @override
  final bool? dynamicRegistration;

  factory _$CodeActionCapabilities(
          [void Function(CodeActionCapabilitiesBuilder)? updates]) =>
      (new CodeActionCapabilitiesBuilder()..update(updates)).build();

  _$CodeActionCapabilities._(
      {this.codeActionLiteralSupport, this.dynamicRegistration})
      : super._();

  @override
  CodeActionCapabilities rebuild(
          void Function(CodeActionCapabilitiesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CodeActionCapabilitiesBuilder toBuilder() =>
      new CodeActionCapabilitiesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CodeActionCapabilities &&
        codeActionLiteralSupport == other.codeActionLiteralSupport &&
        dynamicRegistration == other.dynamicRegistration;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, codeActionLiteralSupport.hashCode),
        dynamicRegistration.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CodeActionCapabilities')
          ..add('codeActionLiteralSupport', codeActionLiteralSupport)
          ..add('dynamicRegistration', dynamicRegistration))
        .toString();
  }
}

class CodeActionCapabilitiesBuilder
    implements Builder<CodeActionCapabilities, CodeActionCapabilitiesBuilder> {
  _$CodeActionCapabilities? _$v;

  CodeActionLiteralSupportBuilder? _codeActionLiteralSupport;
  CodeActionLiteralSupportBuilder get codeActionLiteralSupport =>
      _$this._codeActionLiteralSupport ??=
          new CodeActionLiteralSupportBuilder();
  set codeActionLiteralSupport(
          CodeActionLiteralSupportBuilder? codeActionLiteralSupport) =>
      _$this._codeActionLiteralSupport = codeActionLiteralSupport;

  bool? _dynamicRegistration;
  bool? get dynamicRegistration => _$this._dynamicRegistration;
  set dynamicRegistration(bool? dynamicRegistration) =>
      _$this._dynamicRegistration = dynamicRegistration;

  CodeActionCapabilitiesBuilder();

  CodeActionCapabilitiesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _codeActionLiteralSupport = $v.codeActionLiteralSupport?.toBuilder();
      _dynamicRegistration = $v.dynamicRegistration;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CodeActionCapabilities other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CodeActionCapabilities;
  }

  @override
  void update(void Function(CodeActionCapabilitiesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CodeActionCapabilities build() {
    _$CodeActionCapabilities _$result;
    try {
      _$result = _$v ??
          new _$CodeActionCapabilities._(
              codeActionLiteralSupport: _codeActionLiteralSupport?.build(),
              dynamicRegistration: dynamicRegistration);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'codeActionLiteralSupport';
        _codeActionLiteralSupport?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'CodeActionCapabilities', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$CodeActionLiteralSupport extends CodeActionLiteralSupport {
  @override
  final CodeActionKinds? codeActionKind;

  factory _$CodeActionLiteralSupport(
          [void Function(CodeActionLiteralSupportBuilder)? updates]) =>
      (new CodeActionLiteralSupportBuilder()..update(updates)).build();

  _$CodeActionLiteralSupport._({this.codeActionKind}) : super._();

  @override
  CodeActionLiteralSupport rebuild(
          void Function(CodeActionLiteralSupportBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CodeActionLiteralSupportBuilder toBuilder() =>
      new CodeActionLiteralSupportBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CodeActionLiteralSupport &&
        codeActionKind == other.codeActionKind;
  }

  @override
  int get hashCode {
    return $jf($jc(0, codeActionKind.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CodeActionLiteralSupport')
          ..add('codeActionKind', codeActionKind))
        .toString();
  }
}

class CodeActionLiteralSupportBuilder
    implements
        Builder<CodeActionLiteralSupport, CodeActionLiteralSupportBuilder> {
  _$CodeActionLiteralSupport? _$v;

  CodeActionKindsBuilder? _codeActionKind;
  CodeActionKindsBuilder get codeActionKind =>
      _$this._codeActionKind ??= new CodeActionKindsBuilder();
  set codeActionKind(CodeActionKindsBuilder? codeActionKind) =>
      _$this._codeActionKind = codeActionKind;

  CodeActionLiteralSupportBuilder();

  CodeActionLiteralSupportBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _codeActionKind = $v.codeActionKind?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CodeActionLiteralSupport other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CodeActionLiteralSupport;
  }

  @override
  void update(void Function(CodeActionLiteralSupportBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CodeActionLiteralSupport build() {
    _$CodeActionLiteralSupport _$result;
    try {
      _$result = _$v ??
          new _$CodeActionLiteralSupport._(
              codeActionKind: _codeActionKind?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'codeActionKind';
        _codeActionKind?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'CodeActionLiteralSupport', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$CodeActionKinds extends CodeActionKinds {
  @override
  final BuiltList<String>? valueSet;

  factory _$CodeActionKinds([void Function(CodeActionKindsBuilder)? updates]) =>
      (new CodeActionKindsBuilder()..update(updates)).build();

  _$CodeActionKinds._({this.valueSet}) : super._();

  @override
  CodeActionKinds rebuild(void Function(CodeActionKindsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CodeActionKindsBuilder toBuilder() =>
      new CodeActionKindsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CodeActionKinds && valueSet == other.valueSet;
  }

  @override
  int get hashCode {
    return $jf($jc(0, valueSet.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CodeActionKinds')
          ..add('valueSet', valueSet))
        .toString();
  }
}

class CodeActionKindsBuilder
    implements Builder<CodeActionKinds, CodeActionKindsBuilder> {
  _$CodeActionKinds? _$v;

  ListBuilder<String>? _valueSet;
  ListBuilder<String> get valueSet =>
      _$this._valueSet ??= new ListBuilder<String>();
  set valueSet(ListBuilder<String>? valueSet) => _$this._valueSet = valueSet;

  CodeActionKindsBuilder();

  CodeActionKindsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _valueSet = $v.valueSet?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CodeActionKinds other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CodeActionKinds;
  }

  @override
  void update(void Function(CodeActionKindsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CodeActionKinds build() {
    _$CodeActionKinds _$result;
    try {
      _$result = _$v ?? new _$CodeActionKinds._(valueSet: _valueSet?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'valueSet';
        _valueSet?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'CodeActionKinds', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$CompletionCapabilities extends CompletionCapabilities {
  @override
  final CompletionItemCapabilities? completionItem;
  @override
  final bool? dynamicRegistration;

  factory _$CompletionCapabilities(
          [void Function(CompletionCapabilitiesBuilder)? updates]) =>
      (new CompletionCapabilitiesBuilder()..update(updates)).build();

  _$CompletionCapabilities._({this.completionItem, this.dynamicRegistration})
      : super._();

  @override
  CompletionCapabilities rebuild(
          void Function(CompletionCapabilitiesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CompletionCapabilitiesBuilder toBuilder() =>
      new CompletionCapabilitiesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CompletionCapabilities &&
        completionItem == other.completionItem &&
        dynamicRegistration == other.dynamicRegistration;
  }

  @override
  int get hashCode {
    return $jf(
        $jc($jc(0, completionItem.hashCode), dynamicRegistration.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CompletionCapabilities')
          ..add('completionItem', completionItem)
          ..add('dynamicRegistration', dynamicRegistration))
        .toString();
  }
}

class CompletionCapabilitiesBuilder
    implements Builder<CompletionCapabilities, CompletionCapabilitiesBuilder> {
  _$CompletionCapabilities? _$v;

  CompletionItemCapabilitiesBuilder? _completionItem;
  CompletionItemCapabilitiesBuilder get completionItem =>
      _$this._completionItem ??= new CompletionItemCapabilitiesBuilder();
  set completionItem(CompletionItemCapabilitiesBuilder? completionItem) =>
      _$this._completionItem = completionItem;

  bool? _dynamicRegistration;
  bool? get dynamicRegistration => _$this._dynamicRegistration;
  set dynamicRegistration(bool? dynamicRegistration) =>
      _$this._dynamicRegistration = dynamicRegistration;

  CompletionCapabilitiesBuilder();

  CompletionCapabilitiesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _completionItem = $v.completionItem?.toBuilder();
      _dynamicRegistration = $v.dynamicRegistration;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CompletionCapabilities other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CompletionCapabilities;
  }

  @override
  void update(void Function(CompletionCapabilitiesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CompletionCapabilities build() {
    _$CompletionCapabilities _$result;
    try {
      _$result = _$v ??
          new _$CompletionCapabilities._(
              completionItem: _completionItem?.build(),
              dynamicRegistration: dynamicRegistration);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'completionItem';
        _completionItem?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'CompletionCapabilities', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$CompletionItemCapabilities extends CompletionItemCapabilities {
  @override
  final bool? snippetSupport;

  factory _$CompletionItemCapabilities(
          [void Function(CompletionItemCapabilitiesBuilder)? updates]) =>
      (new CompletionItemCapabilitiesBuilder()..update(updates)).build();

  _$CompletionItemCapabilities._({this.snippetSupport}) : super._();

  @override
  CompletionItemCapabilities rebuild(
          void Function(CompletionItemCapabilitiesBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CompletionItemCapabilitiesBuilder toBuilder() =>
      new CompletionItemCapabilitiesBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CompletionItemCapabilities &&
        snippetSupport == other.snippetSupport;
  }

  @override
  int get hashCode {
    return $jf($jc(0, snippetSupport.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CompletionItemCapabilities')
          ..add('snippetSupport', snippetSupport))
        .toString();
  }
}

class CompletionItemCapabilitiesBuilder
    implements
        Builder<CompletionItemCapabilities, CompletionItemCapabilitiesBuilder> {
  _$CompletionItemCapabilities? _$v;

  bool? _snippetSupport;
  bool? get snippetSupport => _$this._snippetSupport;
  set snippetSupport(bool? snippetSupport) =>
      _$this._snippetSupport = snippetSupport;

  CompletionItemCapabilitiesBuilder();

  CompletionItemCapabilitiesBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _snippetSupport = $v.snippetSupport;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CompletionItemCapabilities other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CompletionItemCapabilities;
  }

  @override
  void update(void Function(CompletionItemCapabilitiesBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CompletionItemCapabilities build() {
    final _$result = _$v ??
        new _$CompletionItemCapabilities._(snippetSupport: snippetSupport);
    replace(_$result);
    return _$result;
  }
}

class _$CodeLensOptions extends CodeLensOptions {
  @override
  final bool? resolveProvider;

  factory _$CodeLensOptions([void Function(CodeLensOptionsBuilder)? updates]) =>
      (new CodeLensOptionsBuilder()..update(updates)).build();

  _$CodeLensOptions._({this.resolveProvider}) : super._();

  @override
  CodeLensOptions rebuild(void Function(CodeLensOptionsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CodeLensOptionsBuilder toBuilder() =>
      new CodeLensOptionsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CodeLensOptions && resolveProvider == other.resolveProvider;
  }

  @override
  int get hashCode {
    return $jf($jc(0, resolveProvider.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CodeLensOptions')
          ..add('resolveProvider', resolveProvider))
        .toString();
  }
}

class CodeLensOptionsBuilder
    implements Builder<CodeLensOptions, CodeLensOptionsBuilder> {
  _$CodeLensOptions? _$v;

  bool? _resolveProvider;
  bool? get resolveProvider => _$this._resolveProvider;
  set resolveProvider(bool? resolveProvider) =>
      _$this._resolveProvider = resolveProvider;

  CodeLensOptionsBuilder();

  CodeLensOptionsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _resolveProvider = $v.resolveProvider;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CodeLensOptions other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CodeLensOptions;
  }

  @override
  void update(void Function(CodeLensOptionsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CodeLensOptions build() {
    final _$result =
        _$v ?? new _$CodeLensOptions._(resolveProvider: resolveProvider);
    replace(_$result);
    return _$result;
  }
}

class _$CompletionOptions extends CompletionOptions {
  @override
  final bool? resolveProvider;
  @override
  final BuiltList<String>? triggerCharacters;

  factory _$CompletionOptions(
          [void Function(CompletionOptionsBuilder)? updates]) =>
      (new CompletionOptionsBuilder()..update(updates)).build();

  _$CompletionOptions._({this.resolveProvider, this.triggerCharacters})
      : super._();

  @override
  CompletionOptions rebuild(void Function(CompletionOptionsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CompletionOptionsBuilder toBuilder() =>
      new CompletionOptionsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CompletionOptions &&
        resolveProvider == other.resolveProvider &&
        triggerCharacters == other.triggerCharacters;
  }

  @override
  int get hashCode {
    return $jf(
        $jc($jc(0, resolveProvider.hashCode), triggerCharacters.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CompletionOptions')
          ..add('resolveProvider', resolveProvider)
          ..add('triggerCharacters', triggerCharacters))
        .toString();
  }
}

class CompletionOptionsBuilder
    implements Builder<CompletionOptions, CompletionOptionsBuilder> {
  _$CompletionOptions? _$v;

  bool? _resolveProvider;
  bool? get resolveProvider => _$this._resolveProvider;
  set resolveProvider(bool? resolveProvider) =>
      _$this._resolveProvider = resolveProvider;

  ListBuilder<String>? _triggerCharacters;
  ListBuilder<String> get triggerCharacters =>
      _$this._triggerCharacters ??= new ListBuilder<String>();
  set triggerCharacters(ListBuilder<String>? triggerCharacters) =>
      _$this._triggerCharacters = triggerCharacters;

  CompletionOptionsBuilder();

  CompletionOptionsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _resolveProvider = $v.resolveProvider;
      _triggerCharacters = $v.triggerCharacters?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CompletionOptions other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CompletionOptions;
  }

  @override
  void update(void Function(CompletionOptionsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CompletionOptions build() {
    _$CompletionOptions _$result;
    try {
      _$result = _$v ??
          new _$CompletionOptions._(
              resolveProvider: resolveProvider,
              triggerCharacters: _triggerCharacters?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'triggerCharacters';
        _triggerCharacters?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'CompletionOptions', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$DocumentLinkOptions extends DocumentLinkOptions {
  @override
  final bool? resolveProvider;

  factory _$DocumentLinkOptions(
          [void Function(DocumentLinkOptionsBuilder)? updates]) =>
      (new DocumentLinkOptionsBuilder()..update(updates)).build();

  _$DocumentLinkOptions._({this.resolveProvider}) : super._();

  @override
  DocumentLinkOptions rebuild(
          void Function(DocumentLinkOptionsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  DocumentLinkOptionsBuilder toBuilder() =>
      new DocumentLinkOptionsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is DocumentLinkOptions &&
        resolveProvider == other.resolveProvider;
  }

  @override
  int get hashCode {
    return $jf($jc(0, resolveProvider.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('DocumentLinkOptions')
          ..add('resolveProvider', resolveProvider))
        .toString();
  }
}

class DocumentLinkOptionsBuilder
    implements Builder<DocumentLinkOptions, DocumentLinkOptionsBuilder> {
  _$DocumentLinkOptions? _$v;

  bool? _resolveProvider;
  bool? get resolveProvider => _$this._resolveProvider;
  set resolveProvider(bool? resolveProvider) =>
      _$this._resolveProvider = resolveProvider;

  DocumentLinkOptionsBuilder();

  DocumentLinkOptionsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _resolveProvider = $v.resolveProvider;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(DocumentLinkOptions other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$DocumentLinkOptions;
  }

  @override
  void update(void Function(DocumentLinkOptionsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$DocumentLinkOptions build() {
    final _$result =
        _$v ?? new _$DocumentLinkOptions._(resolveProvider: resolveProvider);
    replace(_$result);
    return _$result;
  }
}

class _$DocumentOnTypeFormattingOptions
    extends DocumentOnTypeFormattingOptions {
  @override
  final String? firstTriggerCharacter;
  @override
  final BuiltList<String>? moreTriggerCharacter;

  factory _$DocumentOnTypeFormattingOptions(
          [void Function(DocumentOnTypeFormattingOptionsBuilder)? updates]) =>
      (new DocumentOnTypeFormattingOptionsBuilder()..update(updates)).build();

  _$DocumentOnTypeFormattingOptions._(
      {this.firstTriggerCharacter, this.moreTriggerCharacter})
      : super._();

  @override
  DocumentOnTypeFormattingOptions rebuild(
          void Function(DocumentOnTypeFormattingOptionsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  DocumentOnTypeFormattingOptionsBuilder toBuilder() =>
      new DocumentOnTypeFormattingOptionsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is DocumentOnTypeFormattingOptions &&
        firstTriggerCharacter == other.firstTriggerCharacter &&
        moreTriggerCharacter == other.moreTriggerCharacter;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(0, firstTriggerCharacter.hashCode), moreTriggerCharacter.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('DocumentOnTypeFormattingOptions')
          ..add('firstTriggerCharacter', firstTriggerCharacter)
          ..add('moreTriggerCharacter', moreTriggerCharacter))
        .toString();
  }
}

class DocumentOnTypeFormattingOptionsBuilder
    implements
        Builder<DocumentOnTypeFormattingOptions,
            DocumentOnTypeFormattingOptionsBuilder> {
  _$DocumentOnTypeFormattingOptions? _$v;

  String? _firstTriggerCharacter;
  String? get firstTriggerCharacter => _$this._firstTriggerCharacter;
  set firstTriggerCharacter(String? firstTriggerCharacter) =>
      _$this._firstTriggerCharacter = firstTriggerCharacter;

  ListBuilder<String>? _moreTriggerCharacter;
  ListBuilder<String> get moreTriggerCharacter =>
      _$this._moreTriggerCharacter ??= new ListBuilder<String>();
  set moreTriggerCharacter(ListBuilder<String>? moreTriggerCharacter) =>
      _$this._moreTriggerCharacter = moreTriggerCharacter;

  DocumentOnTypeFormattingOptionsBuilder();

  DocumentOnTypeFormattingOptionsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _firstTriggerCharacter = $v.firstTriggerCharacter;
      _moreTriggerCharacter = $v.moreTriggerCharacter?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(DocumentOnTypeFormattingOptions other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$DocumentOnTypeFormattingOptions;
  }

  @override
  void update(void Function(DocumentOnTypeFormattingOptionsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$DocumentOnTypeFormattingOptions build() {
    _$DocumentOnTypeFormattingOptions _$result;
    try {
      _$result = _$v ??
          new _$DocumentOnTypeFormattingOptions._(
              firstTriggerCharacter: firstTriggerCharacter,
              moreTriggerCharacter: _moreTriggerCharacter?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'moreTriggerCharacter';
        _moreTriggerCharacter?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'DocumentOnTypeFormattingOptions', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$ExecuteCommandOptions extends ExecuteCommandOptions {
  @override
  final BuiltList<String>? commands;

  factory _$ExecuteCommandOptions(
          [void Function(ExecuteCommandOptionsBuilder)? updates]) =>
      (new ExecuteCommandOptionsBuilder()..update(updates)).build();

  _$ExecuteCommandOptions._({this.commands}) : super._();

  @override
  ExecuteCommandOptions rebuild(
          void Function(ExecuteCommandOptionsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  ExecuteCommandOptionsBuilder toBuilder() =>
      new ExecuteCommandOptionsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ExecuteCommandOptions && commands == other.commands;
  }

  @override
  int get hashCode {
    return $jf($jc(0, commands.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('ExecuteCommandOptions')
          ..add('commands', commands))
        .toString();
  }
}

class ExecuteCommandOptionsBuilder
    implements Builder<ExecuteCommandOptions, ExecuteCommandOptionsBuilder> {
  _$ExecuteCommandOptions? _$v;

  ListBuilder<String>? _commands;
  ListBuilder<String> get commands =>
      _$this._commands ??= new ListBuilder<String>();
  set commands(ListBuilder<String>? commands) => _$this._commands = commands;

  ExecuteCommandOptionsBuilder();

  ExecuteCommandOptionsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _commands = $v.commands?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(ExecuteCommandOptions other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$ExecuteCommandOptions;
  }

  @override
  void update(void Function(ExecuteCommandOptionsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$ExecuteCommandOptions build() {
    _$ExecuteCommandOptions _$result;
    try {
      _$result =
          _$v ?? new _$ExecuteCommandOptions._(commands: _commands?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'commands';
        _commands?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'ExecuteCommandOptions', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$SignatureHelpOptions extends SignatureHelpOptions {
  @override
  final BuiltList<String>? triggerCharacters;

  factory _$SignatureHelpOptions(
          [void Function(SignatureHelpOptionsBuilder)? updates]) =>
      (new SignatureHelpOptionsBuilder()..update(updates)).build();

  _$SignatureHelpOptions._({this.triggerCharacters}) : super._();

  @override
  SignatureHelpOptions rebuild(
          void Function(SignatureHelpOptionsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  SignatureHelpOptionsBuilder toBuilder() =>
      new SignatureHelpOptionsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SignatureHelpOptions &&
        triggerCharacters == other.triggerCharacters;
  }

  @override
  int get hashCode {
    return $jf($jc(0, triggerCharacters.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('SignatureHelpOptions')
          ..add('triggerCharacters', triggerCharacters))
        .toString();
  }
}

class SignatureHelpOptionsBuilder
    implements Builder<SignatureHelpOptions, SignatureHelpOptionsBuilder> {
  _$SignatureHelpOptions? _$v;

  ListBuilder<String>? _triggerCharacters;
  ListBuilder<String> get triggerCharacters =>
      _$this._triggerCharacters ??= new ListBuilder<String>();
  set triggerCharacters(ListBuilder<String>? triggerCharacters) =>
      _$this._triggerCharacters = triggerCharacters;

  SignatureHelpOptionsBuilder();

  SignatureHelpOptionsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _triggerCharacters = $v.triggerCharacters?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(SignatureHelpOptions other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$SignatureHelpOptions;
  }

  @override
  void update(void Function(SignatureHelpOptionsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$SignatureHelpOptions build() {
    _$SignatureHelpOptions _$result;
    try {
      _$result = _$v ??
          new _$SignatureHelpOptions._(
              triggerCharacters: _triggerCharacters?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'triggerCharacters';
        _triggerCharacters?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'SignatureHelpOptions', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$TextDocumentSyncOptions extends TextDocumentSyncOptions {
  @override
  final TextDocumentSyncKind? change;
  @override
  final bool? openClose;
  @override
  final SaveOptions? save;
  @override
  final bool? willSave;
  @override
  final bool? willSaveWaitUntil;

  factory _$TextDocumentSyncOptions(
          [void Function(TextDocumentSyncOptionsBuilder)? updates]) =>
      (new TextDocumentSyncOptionsBuilder()..update(updates)).build();

  _$TextDocumentSyncOptions._(
      {this.change,
      this.openClose,
      this.save,
      this.willSave,
      this.willSaveWaitUntil})
      : super._();

  @override
  TextDocumentSyncOptions rebuild(
          void Function(TextDocumentSyncOptionsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  TextDocumentSyncOptionsBuilder toBuilder() =>
      new TextDocumentSyncOptionsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TextDocumentSyncOptions &&
        change == other.change &&
        openClose == other.openClose &&
        save == other.save &&
        willSave == other.willSave &&
        willSaveWaitUntil == other.willSaveWaitUntil;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc($jc($jc(0, change.hashCode), openClose.hashCode),
                save.hashCode),
            willSave.hashCode),
        willSaveWaitUntil.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('TextDocumentSyncOptions')
          ..add('change', change)
          ..add('openClose', openClose)
          ..add('save', save)
          ..add('willSave', willSave)
          ..add('willSaveWaitUntil', willSaveWaitUntil))
        .toString();
  }
}

class TextDocumentSyncOptionsBuilder
    implements
        Builder<TextDocumentSyncOptions, TextDocumentSyncOptionsBuilder> {
  _$TextDocumentSyncOptions? _$v;

  TextDocumentSyncKind? _change;
  TextDocumentSyncKind? get change => _$this._change;
  set change(TextDocumentSyncKind? change) => _$this._change = change;

  bool? _openClose;
  bool? get openClose => _$this._openClose;
  set openClose(bool? openClose) => _$this._openClose = openClose;

  SaveOptionsBuilder? _save;
  SaveOptionsBuilder get save => _$this._save ??= new SaveOptionsBuilder();
  set save(SaveOptionsBuilder? save) => _$this._save = save;

  bool? _willSave;
  bool? get willSave => _$this._willSave;
  set willSave(bool? willSave) => _$this._willSave = willSave;

  bool? _willSaveWaitUntil;
  bool? get willSaveWaitUntil => _$this._willSaveWaitUntil;
  set willSaveWaitUntil(bool? willSaveWaitUntil) =>
      _$this._willSaveWaitUntil = willSaveWaitUntil;

  TextDocumentSyncOptionsBuilder();

  TextDocumentSyncOptionsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _change = $v.change;
      _openClose = $v.openClose;
      _save = $v.save?.toBuilder();
      _willSave = $v.willSave;
      _willSaveWaitUntil = $v.willSaveWaitUntil;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(TextDocumentSyncOptions other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$TextDocumentSyncOptions;
  }

  @override
  void update(void Function(TextDocumentSyncOptionsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$TextDocumentSyncOptions build() {
    _$TextDocumentSyncOptions _$result;
    try {
      _$result = _$v ??
          new _$TextDocumentSyncOptions._(
              change: change,
              openClose: openClose,
              save: _save?.build(),
              willSave: willSave,
              willSaveWaitUntil: willSaveWaitUntil);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'save';
        _save?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'TextDocumentSyncOptions', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$SaveOptions extends SaveOptions {
  @override
  final bool? includeText;

  factory _$SaveOptions([void Function(SaveOptionsBuilder)? updates]) =>
      (new SaveOptionsBuilder()..update(updates)).build();

  _$SaveOptions._({this.includeText}) : super._();

  @override
  SaveOptions rebuild(void Function(SaveOptionsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  SaveOptionsBuilder toBuilder() => new SaveOptionsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SaveOptions && includeText == other.includeText;
  }

  @override
  int get hashCode {
    return $jf($jc(0, includeText.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('SaveOptions')
          ..add('includeText', includeText))
        .toString();
  }
}

class SaveOptionsBuilder implements Builder<SaveOptions, SaveOptionsBuilder> {
  _$SaveOptions? _$v;

  bool? _includeText;
  bool? get includeText => _$this._includeText;
  set includeText(bool? includeText) => _$this._includeText = includeText;

  SaveOptionsBuilder();

  SaveOptionsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _includeText = $v.includeText;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(SaveOptions other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$SaveOptions;
  }

  @override
  void update(void Function(SaveOptionsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$SaveOptions build() {
    final _$result = _$v ?? new _$SaveOptions._(includeText: includeText);
    replace(_$result);
    return _$result;
  }
}

class _$TextDocumentItem extends TextDocumentItem {
  @override
  final String? languageId;
  @override
  final String? text;
  @override
  final String? uri;
  @override
  final int? version;

  factory _$TextDocumentItem(
          [void Function(TextDocumentItemBuilder)? updates]) =>
      (new TextDocumentItemBuilder()..update(updates)).build();

  _$TextDocumentItem._({this.languageId, this.text, this.uri, this.version})
      : super._();

  @override
  TextDocumentItem rebuild(void Function(TextDocumentItemBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  TextDocumentItemBuilder toBuilder() =>
      new TextDocumentItemBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TextDocumentItem &&
        languageId == other.languageId &&
        text == other.text &&
        uri == other.uri &&
        version == other.version;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc($jc($jc(0, languageId.hashCode), text.hashCode), uri.hashCode),
        version.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('TextDocumentItem')
          ..add('languageId', languageId)
          ..add('text', text)
          ..add('uri', uri)
          ..add('version', version))
        .toString();
  }
}

class TextDocumentItemBuilder
    implements Builder<TextDocumentItem, TextDocumentItemBuilder> {
  _$TextDocumentItem? _$v;

  String? _languageId;
  String? get languageId => _$this._languageId;
  set languageId(String? languageId) => _$this._languageId = languageId;

  String? _text;
  String? get text => _$this._text;
  set text(String? text) => _$this._text = text;

  String? _uri;
  String? get uri => _$this._uri;
  set uri(String? uri) => _$this._uri = uri;

  int? _version;
  int? get version => _$this._version;
  set version(int? version) => _$this._version = version;

  TextDocumentItemBuilder();

  TextDocumentItemBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _languageId = $v.languageId;
      _text = $v.text;
      _uri = $v.uri;
      _version = $v.version;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(TextDocumentItem other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$TextDocumentItem;
  }

  @override
  void update(void Function(TextDocumentItemBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$TextDocumentItem build() {
    final _$result = _$v ??
        new _$TextDocumentItem._(
            languageId: languageId, text: text, uri: uri, version: version);
    replace(_$result);
    return _$result;
  }
}

class _$VersionedTextDocumentIdentifier
    extends VersionedTextDocumentIdentifier {
  @override
  final String? uri;
  @override
  final int? version;

  factory _$VersionedTextDocumentIdentifier(
          [void Function(VersionedTextDocumentIdentifierBuilder)? updates]) =>
      (new VersionedTextDocumentIdentifierBuilder()..update(updates)).build();

  _$VersionedTextDocumentIdentifier._({this.uri, this.version}) : super._();

  @override
  VersionedTextDocumentIdentifier rebuild(
          void Function(VersionedTextDocumentIdentifierBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  VersionedTextDocumentIdentifierBuilder toBuilder() =>
      new VersionedTextDocumentIdentifierBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is VersionedTextDocumentIdentifier &&
        uri == other.uri &&
        version == other.version;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, uri.hashCode), version.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('VersionedTextDocumentIdentifier')
          ..add('uri', uri)
          ..add('version', version))
        .toString();
  }
}

class VersionedTextDocumentIdentifierBuilder
    implements
        Builder<VersionedTextDocumentIdentifier,
            VersionedTextDocumentIdentifierBuilder> {
  _$VersionedTextDocumentIdentifier? _$v;

  String? _uri;
  String? get uri => _$this._uri;
  set uri(String? uri) => _$this._uri = uri;

  int? _version;
  int? get version => _$this._version;
  set version(int? version) => _$this._version = version;

  VersionedTextDocumentIdentifierBuilder();

  VersionedTextDocumentIdentifierBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _uri = $v.uri;
      _version = $v.version;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(VersionedTextDocumentIdentifier other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$VersionedTextDocumentIdentifier;
  }

  @override
  void update(void Function(VersionedTextDocumentIdentifierBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$VersionedTextDocumentIdentifier build() {
    final _$result = _$v ??
        new _$VersionedTextDocumentIdentifier._(uri: uri, version: version);
    replace(_$result);
    return _$result;
  }
}

class _$TextDocumentContentChangeEvent extends TextDocumentContentChangeEvent {
  @override
  final Range? range;
  @override
  final int? rangeLength;
  @override
  final String? text;

  factory _$TextDocumentContentChangeEvent(
          [void Function(TextDocumentContentChangeEventBuilder)? updates]) =>
      (new TextDocumentContentChangeEventBuilder()..update(updates)).build();

  _$TextDocumentContentChangeEvent._({this.range, this.rangeLength, this.text})
      : super._();

  @override
  TextDocumentContentChangeEvent rebuild(
          void Function(TextDocumentContentChangeEventBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  TextDocumentContentChangeEventBuilder toBuilder() =>
      new TextDocumentContentChangeEventBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TextDocumentContentChangeEvent &&
        range == other.range &&
        rangeLength == other.rangeLength &&
        text == other.text;
  }

  @override
  int get hashCode {
    return $jf(
        $jc($jc($jc(0, range.hashCode), rangeLength.hashCode), text.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('TextDocumentContentChangeEvent')
          ..add('range', range)
          ..add('rangeLength', rangeLength)
          ..add('text', text))
        .toString();
  }
}

class TextDocumentContentChangeEventBuilder
    implements
        Builder<TextDocumentContentChangeEvent,
            TextDocumentContentChangeEventBuilder> {
  _$TextDocumentContentChangeEvent? _$v;

  RangeBuilder? _range;
  RangeBuilder get range => _$this._range ??= new RangeBuilder();
  set range(RangeBuilder? range) => _$this._range = range;

  int? _rangeLength;
  int? get rangeLength => _$this._rangeLength;
  set rangeLength(int? rangeLength) => _$this._rangeLength = rangeLength;

  String? _text;
  String? get text => _$this._text;
  set text(String? text) => _$this._text = text;

  TextDocumentContentChangeEventBuilder();

  TextDocumentContentChangeEventBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _range = $v.range?.toBuilder();
      _rangeLength = $v.rangeLength;
      _text = $v.text;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(TextDocumentContentChangeEvent other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$TextDocumentContentChangeEvent;
  }

  @override
  void update(void Function(TextDocumentContentChangeEventBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$TextDocumentContentChangeEvent build() {
    _$TextDocumentContentChangeEvent _$result;
    try {
      _$result = _$v ??
          new _$TextDocumentContentChangeEvent._(
              range: _range?.build(), rangeLength: rangeLength, text: text);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'range';
        _range?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'TextDocumentContentChangeEvent', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Range extends Range {
  @override
  final Position? end;
  @override
  final Position? start;

  factory _$Range([void Function(RangeBuilder)? updates]) =>
      (new RangeBuilder()..update(updates)).build();

  _$Range._({this.end, this.start}) : super._();

  @override
  Range rebuild(void Function(RangeBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  RangeBuilder toBuilder() => new RangeBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Range && end == other.end && start == other.start;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, end.hashCode), start.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('Range')
          ..add('end', end)
          ..add('start', start))
        .toString();
  }
}

class RangeBuilder implements Builder<Range, RangeBuilder> {
  _$Range? _$v;

  PositionBuilder? _end;
  PositionBuilder get end => _$this._end ??= new PositionBuilder();
  set end(PositionBuilder? end) => _$this._end = end;

  PositionBuilder? _start;
  PositionBuilder get start => _$this._start ??= new PositionBuilder();
  set start(PositionBuilder? start) => _$this._start = start;

  RangeBuilder();

  RangeBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _end = $v.end?.toBuilder();
      _start = $v.start?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Range other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Range;
  }

  @override
  void update(void Function(RangeBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$Range build() {
    _$Range _$result;
    try {
      _$result =
          _$v ?? new _$Range._(end: _end?.build(), start: _start?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'end';
        _end?.build();
        _$failedField = 'start';
        _start?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'Range', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Position extends Position {
  @override
  final int? character;
  @override
  final int? line;

  factory _$Position([void Function(PositionBuilder)? updates]) =>
      (new PositionBuilder()..update(updates)).build();

  _$Position._({this.character, this.line}) : super._();

  @override
  Position rebuild(void Function(PositionBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  PositionBuilder toBuilder() => new PositionBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Position &&
        character == other.character &&
        line == other.line;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, character.hashCode), line.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('Position')
          ..add('character', character)
          ..add('line', line))
        .toString();
  }
}

class PositionBuilder implements Builder<Position, PositionBuilder> {
  _$Position? _$v;

  int? _character;
  int? get character => _$this._character;
  set character(int? character) => _$this._character = character;

  int? _line;
  int? get line => _$this._line;
  set line(int? line) => _$this._line = line;

  PositionBuilder();

  PositionBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _character = $v.character;
      _line = $v.line;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Position other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Position;
  }

  @override
  void update(void Function(PositionBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$Position build() {
    final _$result = _$v ?? new _$Position._(character: character, line: line);
    replace(_$result);
    return _$result;
  }
}

class _$TextDocumentIdentifier extends TextDocumentIdentifier {
  @override
  final String? uri;

  factory _$TextDocumentIdentifier(
          [void Function(TextDocumentIdentifierBuilder)? updates]) =>
      (new TextDocumentIdentifierBuilder()..update(updates)).build();

  _$TextDocumentIdentifier._({this.uri}) : super._();

  @override
  TextDocumentIdentifier rebuild(
          void Function(TextDocumentIdentifierBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  TextDocumentIdentifierBuilder toBuilder() =>
      new TextDocumentIdentifierBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TextDocumentIdentifier && uri == other.uri;
  }

  @override
  int get hashCode {
    return $jf($jc(0, uri.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('TextDocumentIdentifier')
          ..add('uri', uri))
        .toString();
  }
}

class TextDocumentIdentifierBuilder
    implements Builder<TextDocumentIdentifier, TextDocumentIdentifierBuilder> {
  _$TextDocumentIdentifier? _$v;

  String? _uri;
  String? get uri => _$this._uri;
  set uri(String? uri) => _$this._uri = uri;

  TextDocumentIdentifierBuilder();

  TextDocumentIdentifierBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _uri = $v.uri;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(TextDocumentIdentifier other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$TextDocumentIdentifier;
  }

  @override
  void update(void Function(TextDocumentIdentifierBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$TextDocumentIdentifier build() {
    final _$result = _$v ?? new _$TextDocumentIdentifier._(uri: uri);
    replace(_$result);
    return _$result;
  }
}

class _$CompletionList extends CompletionList {
  @override
  final bool? isIncomplete;
  @override
  final BuiltList<CompletionItem>? items;

  factory _$CompletionList([void Function(CompletionListBuilder)? updates]) =>
      (new CompletionListBuilder()..update(updates)).build();

  _$CompletionList._({this.isIncomplete, this.items}) : super._();

  @override
  CompletionList rebuild(void Function(CompletionListBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CompletionListBuilder toBuilder() =>
      new CompletionListBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CompletionList &&
        isIncomplete == other.isIncomplete &&
        items == other.items;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, isIncomplete.hashCode), items.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CompletionList')
          ..add('isIncomplete', isIncomplete)
          ..add('items', items))
        .toString();
  }
}

class CompletionListBuilder
    implements Builder<CompletionList, CompletionListBuilder> {
  _$CompletionList? _$v;

  bool? _isIncomplete;
  bool? get isIncomplete => _$this._isIncomplete;
  set isIncomplete(bool? isIncomplete) => _$this._isIncomplete = isIncomplete;

  ListBuilder<CompletionItem>? _items;
  ListBuilder<CompletionItem> get items =>
      _$this._items ??= new ListBuilder<CompletionItem>();
  set items(ListBuilder<CompletionItem>? items) => _$this._items = items;

  CompletionListBuilder();

  CompletionListBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _isIncomplete = $v.isIncomplete;
      _items = $v.items?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CompletionList other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CompletionList;
  }

  @override
  void update(void Function(CompletionListBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CompletionList build() {
    _$CompletionList _$result;
    try {
      _$result = _$v ??
          new _$CompletionList._(
              isIncomplete: isIncomplete, items: _items?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'items';
        _items?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'CompletionList', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$CompletionItem extends CompletionItem {
  @override
  final BuiltList<TextEdit>? additionalTextEdits;
  @override
  final Command? command;
  @override
  final BuiltMap<dynamic, dynamic>? data;
  @override
  final String? detail;
  @override
  final String? documentation;
  @override
  final String? filterText;
  @override
  final String? insertText;
  @override
  final InsertTextFormat? insertTextFormat;
  @override
  final CompletionItemKind? kind;
  @override
  final String? label;
  @override
  final String? sortText;
  @override
  final TextEdit? textEdit;

  factory _$CompletionItem([void Function(CompletionItemBuilder)? updates]) =>
      (new CompletionItemBuilder()..update(updates)).build();

  _$CompletionItem._(
      {this.additionalTextEdits,
      this.command,
      this.data,
      this.detail,
      this.documentation,
      this.filterText,
      this.insertText,
      this.insertTextFormat,
      this.kind,
      this.label,
      this.sortText,
      this.textEdit})
      : super._();

  @override
  CompletionItem rebuild(void Function(CompletionItemBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CompletionItemBuilder toBuilder() =>
      new CompletionItemBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CompletionItem &&
        additionalTextEdits == other.additionalTextEdits &&
        command == other.command &&
        data == other.data &&
        detail == other.detail &&
        documentation == other.documentation &&
        filterText == other.filterText &&
        insertText == other.insertText &&
        insertTextFormat == other.insertTextFormat &&
        kind == other.kind &&
        label == other.label &&
        sortText == other.sortText &&
        textEdit == other.textEdit;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc(
                $jc(
                    $jc(
                        $jc(
                            $jc(
                                $jc(
                                    $jc(
                                        $jc(
                                            $jc(
                                                $jc(
                                                    0,
                                                    additionalTextEdits
                                                        .hashCode),
                                                command.hashCode),
                                            data.hashCode),
                                        detail.hashCode),
                                    documentation.hashCode),
                                filterText.hashCode),
                            insertText.hashCode),
                        insertTextFormat.hashCode),
                    kind.hashCode),
                label.hashCode),
            sortText.hashCode),
        textEdit.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CompletionItem')
          ..add('additionalTextEdits', additionalTextEdits)
          ..add('command', command)
          ..add('data', data)
          ..add('detail', detail)
          ..add('documentation', documentation)
          ..add('filterText', filterText)
          ..add('insertText', insertText)
          ..add('insertTextFormat', insertTextFormat)
          ..add('kind', kind)
          ..add('label', label)
          ..add('sortText', sortText)
          ..add('textEdit', textEdit))
        .toString();
  }
}

class CompletionItemBuilder
    implements Builder<CompletionItem, CompletionItemBuilder> {
  _$CompletionItem? _$v;

  ListBuilder<TextEdit>? _additionalTextEdits;
  ListBuilder<TextEdit> get additionalTextEdits =>
      _$this._additionalTextEdits ??= new ListBuilder<TextEdit>();
  set additionalTextEdits(ListBuilder<TextEdit>? additionalTextEdits) =>
      _$this._additionalTextEdits = additionalTextEdits;

  CommandBuilder? _command;
  CommandBuilder get command => _$this._command ??= new CommandBuilder();
  set command(CommandBuilder? command) => _$this._command = command;

  MapBuilder<dynamic, dynamic>? _data;
  MapBuilder<dynamic, dynamic> get data =>
      _$this._data ??= new MapBuilder<dynamic, dynamic>();
  set data(MapBuilder<dynamic, dynamic>? data) => _$this._data = data;

  String? _detail;
  String? get detail => _$this._detail;
  set detail(String? detail) => _$this._detail = detail;

  String? _documentation;
  String? get documentation => _$this._documentation;
  set documentation(String? documentation) =>
      _$this._documentation = documentation;

  String? _filterText;
  String? get filterText => _$this._filterText;
  set filterText(String? filterText) => _$this._filterText = filterText;

  String? _insertText;
  String? get insertText => _$this._insertText;
  set insertText(String? insertText) => _$this._insertText = insertText;

  InsertTextFormat? _insertTextFormat;
  InsertTextFormat? get insertTextFormat => _$this._insertTextFormat;
  set insertTextFormat(InsertTextFormat? insertTextFormat) =>
      _$this._insertTextFormat = insertTextFormat;

  CompletionItemKind? _kind;
  CompletionItemKind? get kind => _$this._kind;
  set kind(CompletionItemKind? kind) => _$this._kind = kind;

  String? _label;
  String? get label => _$this._label;
  set label(String? label) => _$this._label = label;

  String? _sortText;
  String? get sortText => _$this._sortText;
  set sortText(String? sortText) => _$this._sortText = sortText;

  TextEditBuilder? _textEdit;
  TextEditBuilder get textEdit => _$this._textEdit ??= new TextEditBuilder();
  set textEdit(TextEditBuilder? textEdit) => _$this._textEdit = textEdit;

  CompletionItemBuilder();

  CompletionItemBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _additionalTextEdits = $v.additionalTextEdits?.toBuilder();
      _command = $v.command?.toBuilder();
      _data = $v.data?.toBuilder();
      _detail = $v.detail;
      _documentation = $v.documentation;
      _filterText = $v.filterText;
      _insertText = $v.insertText;
      _insertTextFormat = $v.insertTextFormat;
      _kind = $v.kind;
      _label = $v.label;
      _sortText = $v.sortText;
      _textEdit = $v.textEdit?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CompletionItem other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CompletionItem;
  }

  @override
  void update(void Function(CompletionItemBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CompletionItem build() {
    _$CompletionItem _$result;
    try {
      _$result = _$v ??
          new _$CompletionItem._(
              additionalTextEdits: _additionalTextEdits?.build(),
              command: _command?.build(),
              data: _data?.build(),
              detail: detail,
              documentation: documentation,
              filterText: filterText,
              insertText: insertText,
              insertTextFormat: insertTextFormat,
              kind: kind,
              label: label,
              sortText: sortText,
              textEdit: _textEdit?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'additionalTextEdits';
        _additionalTextEdits?.build();
        _$failedField = 'command';
        _command?.build();
        _$failedField = 'data';
        _data?.build();

        _$failedField = 'textEdit';
        _textEdit?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'CompletionItem', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$TextEdit extends TextEdit {
  @override
  final String? newText;
  @override
  final Range? range;

  factory _$TextEdit([void Function(TextEditBuilder)? updates]) =>
      (new TextEditBuilder()..update(updates)).build();

  _$TextEdit._({this.newText, this.range}) : super._();

  @override
  TextEdit rebuild(void Function(TextEditBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  TextEditBuilder toBuilder() => new TextEditBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is TextEdit &&
        newText == other.newText &&
        range == other.range;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, newText.hashCode), range.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('TextEdit')
          ..add('newText', newText)
          ..add('range', range))
        .toString();
  }
}

class TextEditBuilder implements Builder<TextEdit, TextEditBuilder> {
  _$TextEdit? _$v;

  String? _newText;
  String? get newText => _$this._newText;
  set newText(String? newText) => _$this._newText = newText;

  RangeBuilder? _range;
  RangeBuilder get range => _$this._range ??= new RangeBuilder();
  set range(RangeBuilder? range) => _$this._range = range;

  TextEditBuilder();

  TextEditBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _newText = $v.newText;
      _range = $v.range?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(TextEdit other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$TextEdit;
  }

  @override
  void update(void Function(TextEditBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$TextEdit build() {
    _$TextEdit _$result;
    try {
      _$result =
          _$v ?? new _$TextEdit._(newText: newText, range: _range?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'range';
        _range?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'TextEdit', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Command extends Command {
  @override
  final BuiltList<dynamic>? arguments;
  @override
  final String? command;
  @override
  final String? title;

  factory _$Command([void Function(CommandBuilder)? updates]) =>
      (new CommandBuilder()..update(updates)).build();

  _$Command._({this.arguments, this.command, this.title}) : super._();

  @override
  Command rebuild(void Function(CommandBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CommandBuilder toBuilder() => new CommandBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Command &&
        arguments == other.arguments &&
        command == other.command &&
        title == other.title;
  }

  @override
  int get hashCode {
    return $jf(
        $jc($jc($jc(0, arguments.hashCode), command.hashCode), title.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('Command')
          ..add('arguments', arguments)
          ..add('command', command)
          ..add('title', title))
        .toString();
  }
}

class CommandBuilder implements Builder<Command, CommandBuilder> {
  _$Command? _$v;

  ListBuilder<dynamic>? _arguments;
  ListBuilder<dynamic> get arguments =>
      _$this._arguments ??= new ListBuilder<dynamic>();
  set arguments(ListBuilder<dynamic>? arguments) =>
      _$this._arguments = arguments;

  String? _command;
  String? get command => _$this._command;
  set command(String? command) => _$this._command = command;

  String? _title;
  String? get title => _$this._title;
  set title(String? title) => _$this._title = title;

  CommandBuilder();

  CommandBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _arguments = $v.arguments?.toBuilder();
      _command = $v.command;
      _title = $v.title;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Command other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Command;
  }

  @override
  void update(void Function(CommandBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$Command build() {
    _$Command _$result;
    try {
      _$result = _$v ??
          new _$Command._(
              arguments: _arguments?.build(), command: command, title: title);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'arguments';
        _arguments?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'Command', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Location extends Location {
  @override
  final Range? range;
  @override
  final String? uri;

  factory _$Location([void Function(LocationBuilder)? updates]) =>
      (new LocationBuilder()..update(updates)).build();

  _$Location._({this.range, this.uri}) : super._();

  @override
  Location rebuild(void Function(LocationBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  LocationBuilder toBuilder() => new LocationBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Location && range == other.range && uri == other.uri;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, range.hashCode), uri.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('Location')
          ..add('range', range)
          ..add('uri', uri))
        .toString();
  }
}

class LocationBuilder implements Builder<Location, LocationBuilder> {
  _$Location? _$v;

  RangeBuilder? _range;
  RangeBuilder get range => _$this._range ??= new RangeBuilder();
  set range(RangeBuilder? range) => _$this._range = range;

  String? _uri;
  String? get uri => _$this._uri;
  set uri(String? uri) => _$this._uri = uri;

  LocationBuilder();

  LocationBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _range = $v.range?.toBuilder();
      _uri = $v.uri;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Location other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Location;
  }

  @override
  void update(void Function(LocationBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$Location build() {
    _$Location _$result;
    try {
      _$result = _$v ?? new _$Location._(range: _range?.build(), uri: uri);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'range';
        _range?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'Location', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$ReferenceContext extends ReferenceContext {
  @override
  final bool? includeDeclaration;

  factory _$ReferenceContext(
          [void Function(ReferenceContextBuilder)? updates]) =>
      (new ReferenceContextBuilder()..update(updates)).build();

  _$ReferenceContext._({this.includeDeclaration}) : super._();

  @override
  ReferenceContext rebuild(void Function(ReferenceContextBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  ReferenceContextBuilder toBuilder() =>
      new ReferenceContextBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ReferenceContext &&
        includeDeclaration == other.includeDeclaration;
  }

  @override
  int get hashCode {
    return $jf($jc(0, includeDeclaration.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('ReferenceContext')
          ..add('includeDeclaration', includeDeclaration))
        .toString();
  }
}

class ReferenceContextBuilder
    implements Builder<ReferenceContext, ReferenceContextBuilder> {
  _$ReferenceContext? _$v;

  bool? _includeDeclaration;
  bool? get includeDeclaration => _$this._includeDeclaration;
  set includeDeclaration(bool? includeDeclaration) =>
      _$this._includeDeclaration = includeDeclaration;

  ReferenceContextBuilder();

  ReferenceContextBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _includeDeclaration = $v.includeDeclaration;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(ReferenceContext other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$ReferenceContext;
  }

  @override
  void update(void Function(ReferenceContextBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$ReferenceContext build() {
    final _$result =
        _$v ?? new _$ReferenceContext._(includeDeclaration: includeDeclaration);
    replace(_$result);
    return _$result;
  }
}

class _$DocumentHighlight extends DocumentHighlight {
  @override
  final DocumentHighlightKind? kind;
  @override
  final Range? range;

  factory _$DocumentHighlight(
          [void Function(DocumentHighlightBuilder)? updates]) =>
      (new DocumentHighlightBuilder()..update(updates)).build();

  _$DocumentHighlight._({this.kind, this.range}) : super._();

  @override
  DocumentHighlight rebuild(void Function(DocumentHighlightBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  DocumentHighlightBuilder toBuilder() =>
      new DocumentHighlightBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is DocumentHighlight &&
        kind == other.kind &&
        range == other.range;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, kind.hashCode), range.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('DocumentHighlight')
          ..add('kind', kind)
          ..add('range', range))
        .toString();
  }
}

class DocumentHighlightBuilder
    implements Builder<DocumentHighlight, DocumentHighlightBuilder> {
  _$DocumentHighlight? _$v;

  DocumentHighlightKind? _kind;
  DocumentHighlightKind? get kind => _$this._kind;
  set kind(DocumentHighlightKind? kind) => _$this._kind = kind;

  RangeBuilder? _range;
  RangeBuilder get range => _$this._range ??= new RangeBuilder();
  set range(RangeBuilder? range) => _$this._range = range;

  DocumentHighlightBuilder();

  DocumentHighlightBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _kind = $v.kind;
      _range = $v.range?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(DocumentHighlight other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$DocumentHighlight;
  }

  @override
  void update(void Function(DocumentHighlightBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$DocumentHighlight build() {
    _$DocumentHighlight _$result;
    try {
      _$result =
          _$v ?? new _$DocumentHighlight._(kind: kind, range: _range?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'range';
        _range?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'DocumentHighlight', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$SymbolInformation extends SymbolInformation {
  @override
  final String? containerName;
  @override
  final SymbolKind? kind;
  @override
  final Location? location;
  @override
  final String? name;

  factory _$SymbolInformation(
          [void Function(SymbolInformationBuilder)? updates]) =>
      (new SymbolInformationBuilder()..update(updates)).build();

  _$SymbolInformation._(
      {this.containerName, this.kind, this.location, this.name})
      : super._();

  @override
  SymbolInformation rebuild(void Function(SymbolInformationBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  SymbolInformationBuilder toBuilder() =>
      new SymbolInformationBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is SymbolInformation &&
        containerName == other.containerName &&
        kind == other.kind &&
        location == other.location &&
        name == other.name;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc($jc($jc(0, containerName.hashCode), kind.hashCode),
            location.hashCode),
        name.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('SymbolInformation')
          ..add('containerName', containerName)
          ..add('kind', kind)
          ..add('location', location)
          ..add('name', name))
        .toString();
  }
}

class SymbolInformationBuilder
    implements Builder<SymbolInformation, SymbolInformationBuilder> {
  _$SymbolInformation? _$v;

  String? _containerName;
  String? get containerName => _$this._containerName;
  set containerName(String? containerName) =>
      _$this._containerName = containerName;

  SymbolKind? _kind;
  SymbolKind? get kind => _$this._kind;
  set kind(SymbolKind? kind) => _$this._kind = kind;

  LocationBuilder? _location;
  LocationBuilder get location => _$this._location ??= new LocationBuilder();
  set location(LocationBuilder? location) => _$this._location = location;

  String? _name;
  String? get name => _$this._name;
  set name(String? name) => _$this._name = name;

  SymbolInformationBuilder();

  SymbolInformationBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _containerName = $v.containerName;
      _kind = $v.kind;
      _location = $v.location?.toBuilder();
      _name = $v.name;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(SymbolInformation other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$SymbolInformation;
  }

  @override
  void update(void Function(SymbolInformationBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$SymbolInformation build() {
    _$SymbolInformation _$result;
    try {
      _$result = _$v ??
          new _$SymbolInformation._(
              containerName: containerName,
              kind: kind,
              location: _location?.build(),
              name: name);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'location';
        _location?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'SymbolInformation', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$CodeActionContext extends CodeActionContext {
  @override
  final BuiltList<Diagnostic>? diagnostics;

  factory _$CodeActionContext(
          [void Function(CodeActionContextBuilder)? updates]) =>
      (new CodeActionContextBuilder()..update(updates)).build();

  _$CodeActionContext._({this.diagnostics}) : super._();

  @override
  CodeActionContext rebuild(void Function(CodeActionContextBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  CodeActionContextBuilder toBuilder() =>
      new CodeActionContextBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is CodeActionContext && diagnostics == other.diagnostics;
  }

  @override
  int get hashCode {
    return $jf($jc(0, diagnostics.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('CodeActionContext')
          ..add('diagnostics', diagnostics))
        .toString();
  }
}

class CodeActionContextBuilder
    implements Builder<CodeActionContext, CodeActionContextBuilder> {
  _$CodeActionContext? _$v;

  ListBuilder<Diagnostic>? _diagnostics;
  ListBuilder<Diagnostic> get diagnostics =>
      _$this._diagnostics ??= new ListBuilder<Diagnostic>();
  set diagnostics(ListBuilder<Diagnostic>? diagnostics) =>
      _$this._diagnostics = diagnostics;

  CodeActionContextBuilder();

  CodeActionContextBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _diagnostics = $v.diagnostics?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(CodeActionContext other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$CodeActionContext;
  }

  @override
  void update(void Function(CodeActionContextBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$CodeActionContext build() {
    _$CodeActionContext _$result;
    try {
      _$result =
          _$v ?? new _$CodeActionContext._(diagnostics: _diagnostics?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'diagnostics';
        _diagnostics?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'CodeActionContext', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Diagnostic extends Diagnostic {
  @override
  final Object? code;
  @override
  final String? message;
  @override
  final Range? range;
  @override
  final int? severity;
  @override
  final String? source;

  factory _$Diagnostic([void Function(DiagnosticBuilder)? updates]) =>
      (new DiagnosticBuilder()..update(updates)).build();

  _$Diagnostic._(
      {this.code, this.message, this.range, this.severity, this.source})
      : super._();

  @override
  Diagnostic rebuild(void Function(DiagnosticBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  DiagnosticBuilder toBuilder() => new DiagnosticBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Diagnostic &&
        code == other.code &&
        message == other.message &&
        range == other.range &&
        severity == other.severity &&
        source == other.source;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc($jc($jc($jc(0, code.hashCode), message.hashCode), range.hashCode),
            severity.hashCode),
        source.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('Diagnostic')
          ..add('code', code)
          ..add('message', message)
          ..add('range', range)
          ..add('severity', severity)
          ..add('source', source))
        .toString();
  }
}

class DiagnosticBuilder implements Builder<Diagnostic, DiagnosticBuilder> {
  _$Diagnostic? _$v;

  Object? _code;
  Object? get code => _$this._code;
  set code(Object? code) => _$this._code = code;

  String? _message;
  String? get message => _$this._message;
  set message(String? message) => _$this._message = message;

  RangeBuilder? _range;
  RangeBuilder get range => _$this._range ??= new RangeBuilder();
  set range(RangeBuilder? range) => _$this._range = range;

  int? _severity;
  int? get severity => _$this._severity;
  set severity(int? severity) => _$this._severity = severity;

  String? _source;
  String? get source => _$this._source;
  set source(String? source) => _$this._source = source;

  DiagnosticBuilder();

  DiagnosticBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _code = $v.code;
      _message = $v.message;
      _range = $v.range?.toBuilder();
      _severity = $v.severity;
      _source = $v.source;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Diagnostic other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Diagnostic;
  }

  @override
  void update(void Function(DiagnosticBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$Diagnostic build() {
    _$Diagnostic _$result;
    try {
      _$result = _$v ??
          new _$Diagnostic._(
              code: code,
              message: message,
              range: _range?.build(),
              severity: severity,
              source: source);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'range';
        _range?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'Diagnostic', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$WorkspaceEdit extends WorkspaceEdit {
  @override
  final BuiltMap<String, BuiltList<TextEdit>>? changes;

  factory _$WorkspaceEdit([void Function(WorkspaceEditBuilder)? updates]) =>
      (new WorkspaceEditBuilder()..update(updates)).build();

  _$WorkspaceEdit._({this.changes}) : super._();

  @override
  WorkspaceEdit rebuild(void Function(WorkspaceEditBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  WorkspaceEditBuilder toBuilder() => new WorkspaceEditBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is WorkspaceEdit && changes == other.changes;
  }

  @override
  int get hashCode {
    return $jf($jc(0, changes.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('WorkspaceEdit')
          ..add('changes', changes))
        .toString();
  }
}

class WorkspaceEditBuilder
    implements Builder<WorkspaceEdit, WorkspaceEditBuilder> {
  _$WorkspaceEdit? _$v;

  MapBuilder<String, BuiltList<TextEdit>>? _changes;
  MapBuilder<String, BuiltList<TextEdit>> get changes =>
      _$this._changes ??= new MapBuilder<String, BuiltList<TextEdit>>();
  set changes(MapBuilder<String, BuiltList<TextEdit>>? changes) =>
      _$this._changes = changes;

  WorkspaceEditBuilder();

  WorkspaceEditBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _changes = $v.changes?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(WorkspaceEdit other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$WorkspaceEdit;
  }

  @override
  void update(void Function(WorkspaceEditBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$WorkspaceEdit build() {
    _$WorkspaceEdit _$result;
    try {
      _$result = _$v ?? new _$WorkspaceEdit._(changes: _changes?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'changes';
        _changes?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'WorkspaceEdit', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$Diagnostics extends Diagnostics {
  @override
  final BuiltList<Diagnostic>? diagnostics;
  @override
  final String? uri;

  factory _$Diagnostics([void Function(DiagnosticsBuilder)? updates]) =>
      (new DiagnosticsBuilder()..update(updates)).build();

  _$Diagnostics._({this.diagnostics, this.uri}) : super._();

  @override
  Diagnostics rebuild(void Function(DiagnosticsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  DiagnosticsBuilder toBuilder() => new DiagnosticsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is Diagnostics &&
        diagnostics == other.diagnostics &&
        uri == other.uri;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, diagnostics.hashCode), uri.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('Diagnostics')
          ..add('diagnostics', diagnostics)
          ..add('uri', uri))
        .toString();
  }
}

class DiagnosticsBuilder implements Builder<Diagnostics, DiagnosticsBuilder> {
  _$Diagnostics? _$v;

  ListBuilder<Diagnostic>? _diagnostics;
  ListBuilder<Diagnostic> get diagnostics =>
      _$this._diagnostics ??= new ListBuilder<Diagnostic>();
  set diagnostics(ListBuilder<Diagnostic>? diagnostics) =>
      _$this._diagnostics = diagnostics;

  String? _uri;
  String? get uri => _$this._uri;
  set uri(String? uri) => _$this._uri = uri;

  DiagnosticsBuilder();

  DiagnosticsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _diagnostics = $v.diagnostics?.toBuilder();
      _uri = $v.uri;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(Diagnostics other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$Diagnostics;
  }

  @override
  void update(void Function(DiagnosticsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$Diagnostics build() {
    _$Diagnostics _$result;
    try {
      _$result = _$v ??
          new _$Diagnostics._(diagnostics: _diagnostics?.build(), uri: uri);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'diagnostics';
        _diagnostics?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'Diagnostics', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$ApplyWorkspaceEditParams extends ApplyWorkspaceEditParams {
  @override
  final WorkspaceEdit? edit;
  @override
  final String? label;

  factory _$ApplyWorkspaceEditParams(
          [void Function(ApplyWorkspaceEditParamsBuilder)? updates]) =>
      (new ApplyWorkspaceEditParamsBuilder()..update(updates)).build();

  _$ApplyWorkspaceEditParams._({this.edit, this.label}) : super._();

  @override
  ApplyWorkspaceEditParams rebuild(
          void Function(ApplyWorkspaceEditParamsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  ApplyWorkspaceEditParamsBuilder toBuilder() =>
      new ApplyWorkspaceEditParamsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ApplyWorkspaceEditParams &&
        edit == other.edit &&
        label == other.label;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, edit.hashCode), label.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('ApplyWorkspaceEditParams')
          ..add('edit', edit)
          ..add('label', label))
        .toString();
  }
}

class ApplyWorkspaceEditParamsBuilder
    implements
        Builder<ApplyWorkspaceEditParams, ApplyWorkspaceEditParamsBuilder> {
  _$ApplyWorkspaceEditParams? _$v;

  WorkspaceEditBuilder? _edit;
  WorkspaceEditBuilder get edit => _$this._edit ??= new WorkspaceEditBuilder();
  set edit(WorkspaceEditBuilder? edit) => _$this._edit = edit;

  String? _label;
  String? get label => _$this._label;
  set label(String? label) => _$this._label = label;

  ApplyWorkspaceEditParamsBuilder();

  ApplyWorkspaceEditParamsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _edit = $v.edit?.toBuilder();
      _label = $v.label;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(ApplyWorkspaceEditParams other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$ApplyWorkspaceEditParams;
  }

  @override
  void update(void Function(ApplyWorkspaceEditParamsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$ApplyWorkspaceEditParams build() {
    _$ApplyWorkspaceEditParams _$result;
    try {
      _$result = _$v ??
          new _$ApplyWorkspaceEditParams._(edit: _edit?.build(), label: label);
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'edit';
        _edit?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'ApplyWorkspaceEditParams', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$ShowMessageParams extends ShowMessageParams {
  @override
  final String? message;
  @override
  final MessageType? type;

  factory _$ShowMessageParams(
          [void Function(ShowMessageParamsBuilder)? updates]) =>
      (new ShowMessageParamsBuilder()..update(updates)).build();

  _$ShowMessageParams._({this.message, this.type}) : super._();

  @override
  ShowMessageParams rebuild(void Function(ShowMessageParamsBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  ShowMessageParamsBuilder toBuilder() =>
      new ShowMessageParamsBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is ShowMessageParams &&
        message == other.message &&
        type == other.type;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, message.hashCode), type.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('ShowMessageParams')
          ..add('message', message)
          ..add('type', type))
        .toString();
  }
}

class ShowMessageParamsBuilder
    implements Builder<ShowMessageParams, ShowMessageParamsBuilder> {
  _$ShowMessageParams? _$v;

  String? _message;
  String? get message => _$this._message;
  set message(String? message) => _$this._message = message;

  MessageType? _type;
  MessageType? get type => _$this._type;
  set type(MessageType? type) => _$this._type = type;

  ShowMessageParamsBuilder();

  ShowMessageParamsBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _message = $v.message;
      _type = $v.type;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(ShowMessageParams other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$ShowMessageParams;
  }

  @override
  void update(void Function(ShowMessageParamsBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$ShowMessageParams build() {
    final _$result =
        _$v ?? new _$ShowMessageParams._(message: message, type: type);
    replace(_$result);
    return _$result;
  }
}

// ignore_for_file: always_put_control_body_on_new_line,always_specify_types,annotate_overrides,avoid_annotating_with_dynamic,avoid_as,avoid_catches_without_on_clauses,avoid_returning_this,deprecated_member_use_from_same_package,lines_longer_than_80_chars,omit_local_variable_types,prefer_expression_function_bodies,sort_constructors_first,test_types_in_equals,unnecessary_const,unnecessary_new
